{"meta":{"title":"HiCoder","subtitle":"","description":"","author":"shiqiqi","url":"www.hicoder.com.cn","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-05-05T04:39:22.593Z","updated":"2020-05-05T04:39:22.593Z","comments":true,"path":"404.html","permalink":"www.hicoder.com.cn/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"about","date":"2020-05-05T04:37:41.000Z","updated":"2020-05-05T04:37:41.776Z","comments":true,"path":"about/index.html","permalink":"www.hicoder.com.cn/about/index.html","excerpt":"","text":""},{"title":"源代码","date":"2020-05-05T04:37:23.000Z","updated":"2020-05-05T04:42:27.814Z","comments":true,"path":"code/index.html","permalink":"www.hicoder.com.cn/code/index.html","excerpt":"","text":"《量化投资入门指南》 《python 小白入门》"},{"title":"我的朋友们","date":"2020-05-05T06:22:47.188Z","updated":"2020-05-05T06:22:47.188Z","comments":true,"path":"friends/index.html","permalink":"www.hicoder.com.cn/friends/index.html","excerpt":"友链位置","text":"友链位置"},{"title":"mylist","date":"2020-05-05T04:38:30.000Z","updated":"2020-05-05T04:38:30.030Z","comments":true,"path":"mylist/index.html","permalink":"www.hicoder.com.cn/mylist/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-05-05T04:38:20.000Z","updated":"2020-05-05T04:38:20.060Z","comments":true,"path":"tags/index.html","permalink":"www.hicoder.com.cn/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-05-05T06:00:14.000Z","updated":"2020-05-05T06:00:14.852Z","comments":true,"path":"categories/index.html","permalink":"www.hicoder.com.cn/categories/index.html","excerpt":"","text":""},{"title":"课程看板","date":"2020-05-01T02:18:48.000Z","updated":"2020-05-10T07:33:09.247Z","comments":true,"path":"video/index.html","permalink":"www.hicoder.com.cn/video/index.html","excerpt":"","text":"用 hexo 快速搭建个人网站 使用开源的 hexo 框架，结合 github 托管服务，免费快速搭建个人网站或博客 马上学习 量化投资入门指南 一门极简的量化编程入门课，使用 python 语言快速分析金融数据，构建回测模型 马上学习"},{"title":"文档目录","date":"2020-05-05T06:04:05.000Z","updated":"2020-05-12T23:20:51.962Z","comments":true,"path":"doc/index.html","permalink":"www.hicoder.com.cn/doc/index.html","excerpt":"","text":"用hexo快速搭建个人网站量化交易资源整合"}],"posts":[{"title":"只需 15 分钟，轻松搭建个人博客站点","slug":"用hexo快速搭个人网站","date":"2020-05-10T07:41:16.000Z","updated":"2020-05-10T14:19:30.317Z","comments":true,"path":"2020/05/10/用hexo快速搭个人网站/","link":"","permalink":"www.hicoder.com.cn/2020/05/10/%E7%94%A8hexo%E5%BF%AB%E9%80%9F%E6%90%AD%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/","excerpt":"","text":"向那些愿意共享、开源的人致敬！ 用敏捷方法去做课程最近跟朋友们说想做门课程发布出来，但是不知道做什么好。预选的方案是结合JoinQuant制作一门教学视频。但这是个大工程，我们不确定是否有足够多的受众会来听这门课。很可能埋头苦干三个月，结局却是少有人问津。 我很想做点好的东西出来，但我不希望以一个瀑布式的流程做完了才拿着产品问市场要反馈。于是我觉得用敏捷的方式来持续输出课程比较好。 我的想法大概是这样：将视频中的课程尽可能的压缩减小，比如一套课程可以用 10 小节就结束，而每小节10 分钟左右，然后输出课程，听听用户的反馈，从市场中学习些经验，在下次的课程制作中进行改进。 这样就暗合了精益理论的小步前进，持续改善的原则。避免了一条道走到黑的局面。 那为什么想做这个博客搭建的课程呢？首先，每个程序员都愿意拥有一个专属博客站点，如果它既能够免费、又足够轻量级，还会大大提升搭建者的成就感。而 hexo+github 就可以在短短的十几分钟内，建立一个免费的个人博客站点，而且效果很酷。其次我觉得这套技术实在是简单，简单到不会编程的人也能够去做自己的网站。（简单归简单，但想玩好了，还是要花点心思的。） 这套课程我将录制 10 小节，然后发布出来，初步听听大家对我的课程的建议，以便我能够快速成长。 课程基本大纲这套课程的大纲如下： 用 hexo 初始化本地站点（5 分钟） 在 github 构建一个 page（5 分钟） 部署你的网站（5 分钟） 使用免费主题（5 分钟） Fluid 实战之背景设置 Fluid 实战之博客发布 Fluid 实战之评论功能 Fluid 实战之网页统计 Fluid 实战之图片懒加载 域名绑定，把网站告诉你的朋友 从大纲可以看出，前三小节 15 分钟就可以让用户快速搭建起网站来，在后面的章节我专门挑了一个比较好的网站主题 Fulid 来做实战演练，进一步强化学习者的实战能力。 课程上线后，希望各位看官能把宝贵的建议反馈给我，帮助我成长，在这里说声谢谢啦。😉","categories":[{"name":"编程","slug":"编程","permalink":"www.hicoder.com.cn/categories/%E7%BC%96%E7%A8%8B/"},{"name":"hexo","slug":"编程/hexo","permalink":"www.hicoder.com.cn/categories/%E7%BC%96%E7%A8%8B/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"www.hicoder.com.cn/tags/hexo/"},{"name":"github","slug":"github","permalink":"www.hicoder.com.cn/tags/github/"},{"name":"网站","slug":"网站","permalink":"www.hicoder.com.cn/tags/%E7%BD%91%E7%AB%99/"},{"name":"博客","slug":"博客","permalink":"www.hicoder.com.cn/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"精益创业之最小可行产品","slug":"精益创业之最小可行产品","date":"2020-05-08T02:18:48.000Z","updated":"2020-05-09T02:24:16.219Z","comments":true,"path":"2020/05/08/精益创业之最小可行产品/","link":"","permalink":"www.hicoder.com.cn/2020/05/08/%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E4%B9%8B%E6%9C%80%E5%B0%8F%E5%8F%AF%E8%A1%8C%E4%BA%A7%E5%93%81/","excerpt":"","text":"译者语：精益创业的思想已经广为流传，MVP也已成为一个热门术语，但是MVP (Minimum Viable Product，最小可行产品) 这个术语本身却难以把握。到底什么是最小可行产品？仁者见仁、智者见智，这就造成了很多的困惑和担忧。在本文中，Henrik以4个真实而生动的产品开发案例揭示了MVP的本质——最早可体验的/可使用的/令人喜爱的产品。原文作者：Henrik Kniberg原文链接：http://blog.crisp.se/2016/01/25/henrikkniberg/making-sense-of-mvp译者：李洁（Jerry Li） 审校：廖靖斌（Eric Liao） 几年前，我画了这张图，并开始在介绍敏捷和精益开发时使用它： 从那时起，这张图就像病毒一样传播！到处都出现了，在文章中出现，在演讲中出现，甚至在书中出现（Jeff Patton的《用户故事地图》中就出现了——顺便说一下，这是本好书）。很多人告诉我，这张图确实抓住了迭代和增量开发、精益创业以及MVP（最小可行产品）之类的本质。然而也存在一些误解——如果你抛开原始语境而只看这张图的话，自然就会出现这种情况。还有些人批评说它把事情简化过头了，这也是对的。这张图只是一个隐喻而已。它并不是在讲述一个真实的汽车开发过程，而是说明普通的产品开发过程，只是用汽车打比方而已。 不管怎样，既然有了这么多不同的声音，我想是时候对这张图背后的含义做个解释了。 第一个例子——“Not Like This”（“不要这样做”这张图） 下面这行图显示了，对迭代和增量产品开发（又称为敏捷）的一个常见误解。 许多项目失败很大程度上是因为他们做了大爆炸交付（直到100%完成了才构建产品并在项目结束时交付）。我不记得我见过多少因为这个原因而失败的项目（后面有些例子）。然而，当敏捷开发被介绍为一种替代方案时，人们有时候却难以接受半成品时就交付的理念——谁会想要半台汽车呢？设想一下这样的场景： “先生，这是我们首次迭代的产物——一只前轮。您觉得怎么样？” 客户会像这样回答：“见鬼，我订的是整台车，而你却只给我个轮胎！这东西我能用来干嘛？” （顺便说一声，我在这里使用“客户”这个术语，作为一个通用术语，用于代表产品经理、产品负责人以及早期用户之类的人员。） 虽然每次交付的产品越来越接近于完成，但是客户仍然非常生气，因为他得到的车并不完整，仍然不能真正使用。 最后，当产品完成时，客户会像这样说：“最后还是谢谢你！你为什么不一开始就给我这个，而不是给我那些无用的垃圾？” 在这个例子中，客户对最终产品感到满意，因为这就是他所订购的产品。而在现实中，这通常不成立。时间已经过去很久了，但却没有经过任何实际的用户体验，所以产品中很可能充斥着人们基于对用户需求的错误假设而产生的设计缺陷。 因此，右边的那张笑脸只是极其理想的情况。 不管怎样，第一行代表了“劣质的敏捷开发”。从技术上看，它可能是增量和迭代交付的，但由于没有形成真正的反馈环，使得产品开发变得极具风险——并且也绝对不是敏捷开发。 因此，给出了“Not Like This”（不要这样做）这个标题第二个例子——“Like This”（“要这样做”这张图） 现在看第二行。 在这里，我们采用了非常不同的方法。我们都开始于同样的背景——客户订购了一台汽车。但这一次我们并非只构建一台汽车。取而代之的是，我们聚焦于客户想要满足的潜在需求。原来，客户的潜在需求是“我需要更快地从A到达B”，而汽车只是一个可能的解决方案而已。 记住，汽车只是一个隐喻，要考虑任何一种客户定制的产品开发情况。 因此，团队要提供的是他们能够想到的、能够让客户体验、并给予反馈的最小产品。有些人可能会称其为MVP（最小可行产品），不过我更喜欢称其为最早可体验的产品（这种说法更加具体）。 可以根据你自己的喜好来称呼MVP（甚至有些人会基于这个隐喻，称他们的第一个发布版本为“滑板版本”。） 客户不太可能会对这个产品感到满意。这东西好像与他订购的汽车没有半毛钱关系。但是不要紧！这就是重点——我们并不试图让客户在此时就感到满意。我们可能会让少数早期用户感到满意，但我们此时的主要目标只是学习。理论上，团队会事先向客户解释清楚，因此客户也不会太失望。 然而，相对于在第一个例子场景中团队交付的前轮，滑板是一个实际能用的东西，能够帮助客户从A到达B。虽然帮助不大，但聊胜于无。因此我们会告诉客户：“别担心，项目还没有结束，这只是第一个迭代而已。 我们仍然致力于构建一台汽车，但同时请试用并向我们提供反馈”。心思很大，但还得以小功能的可行增量来交付。 我们可能会学习到一些令人惊讶的事情。例如我们可以假象这种场景：客户说他不喜欢滑板，我们问为什么。他说：“我讨厌这个颜色。”我们这样回答：“嗯…，颜色吗？就这些？”客户说：“是的，换成蓝色！除此之外都很好！”你刚刚节省一大笔钱，因为不用再去构建一台汽车！这种可能性不太大，但谁敢肯定一定不会发生呢？ 关键问题是“什么是我们能学习得最快和最便宜的方式？”。我们能否交付甚至比交付滑板还早的东西呢？公共汽车票怎么样？ 这有助于解决客户的问题吗？也许能，也许不能，但通过把东西交到真实客户的手里，我们绝对能够学习到什么。精益创业提供了一个非常棒的模型。它的基础是：列出你对用户的假设，然后按部就班地将其证实或者证伪。 你不用让所有用户体验产品，甚至你也不用为了体验什么而特地构建一个产品。与什么都不做相比较，就算只找一个用户进行原型体验都能让你学到更多。 但是没关系，我们回到滑板的例子。 在办公室里玩了一圈后，客户说：“不错，有点意思，能让我更快地到达咖啡机边上。但是不太稳，我太容易掉下来了。” 因此，下一次迭代我们会试图解决这个问题，或者至少进一步研究这个问题。 现在，客户能够踩着滑板在办公室转悠，而且不会再掉下来！ 客户满意了吗？未必满意，他可能还是有点想要那台车。但在这期间，他实际上正在使用产品，并给予我们反馈。他最大的痛点是难以走得更远点。因此，下次发布的产品会变成类似于自行车的东西。 现在，客户能把活动范围扩大的园区了。Yiihaaa！ 在这个过程中，我们学习到一些新的东西：客户喜欢呼吸新鲜空气。客户是在一个园区，并且其交通主要是在大楼之间转悠。 结果可能自行车是比原先设想的汽车更好的产品。事实上，在体验这个产品时，我们可能会发现，对于汽车来说路太窄了。我们刚刚替客户节省了大量的时间和金钱，并以更短的时间提供给更好的产品！ 现在，你可能会想：“但我们不是应该通过前期的客户背景和需求分析来知道那些吗？”说得好。但在我见过的大多数现实生活中的产品开发场景中，无论前面你做多少分析，当把第一个发布版本交到真实用户手中时，你都会感到惊讶，并且你的很多假设最终都错得离谱。 所以，没错，要提前做一些分析，在开发前要尽可能发掘客户需求。但不要花太多的时间，也不要太相信分析结果 –取而代之的是要开始开发原型和发布版本，那才是真正的学习时间。 无论如何，回到故事。也许客户想要更多特性。有时他需要去另一个城市，而骑自行车实在太慢和太累。因此下一个迭代，我们增加了一个引擎。 这种模式特别适合于软件，因为软件是…嗯..“软的”，你可以随意“改变”软件产品。相对来说，硬件基本上每次都需要重新构建。然而，即使是在硬件项目，通过提供原型并观察和学习客户如何使用您的产品，仍然能得到巨大的好处。只是迭代会要长一点（一般是几个月而不是几周）。就算是实际的汽车公司，如丰田和特斯拉，在生产一款全新型号的汽车前，也会制作大量的原型 （例如草图，3维模型，同尺寸粘土模型，等等）。 那么现在呢？再次，客户可能会对摩托车感到满意。我们可能会提前结束这个项目。大多数产品都充满了复杂且没用的功能。迭代方法真的是一种能够减少功能的方式，或是一种找到最简单和最便宜的客户问题解决方式的方法。尽量接近完美。很有点禅理。 或者，再次，客户可能会选择继续，以及是否修改需求。事实上，有可能我们最终得到的，是与最初设想的一模一样的汽车。然而，更可能的是，我们在过程中获得了重要的见解，并最终结果会略有不同，比如下面这样的汽车： 客户会感到喜出望外！为什么？因为我们在过程中了解到他喜欢呼吸新鲜空气，所以我们最后做了一个调整。 他最终确实得到了汽车——但却是比原计划更好的汽车！ 因此，让我们做个回顾。什么是你的滑板版本？ 上面那个场景（交付一个前轮）太差劲了，因为我们不断交付的是客户根本不能用的东西。如果你了解正在做的东西——你的产品没什么复杂度和风险，或许之前你已经做了几百次同类产品——那么就去做吧，直接上大爆炸方式，构建产品并在完成时交付。 然而，我见过的大多数产品开发工作都极具复杂和风险，而大爆炸方式往往只会导致巨大而昂贵的失败。所以，问题的关键是：“什么是你的滑板版本？” 在产品开发中，你要做的第一件事（在描述完你要为谁解决什么问题之后）就是识别出你的滑板等价物。考虑把滑板作为对最小的、可以交到真实用户手中并获得真实反馈的最小产品的隐喻。或者如果隐喻效果更好，也可以使用“公共汽车票”。 这将给予你急需的反馈环，并让你和客户一起来控制项目-你可以进行学习和作出改变，而非只是一味地遵循计划和希望做到最好的。 让我来看一些现实生活中的例子。 第1个例子：Spotify音乐播放器 “有超过7500万用户，很难让人记得什么时候不用Spotify。但有时会有。当我们琢磨如何才能得到新的CD的时候，当我们在Napster上盗版音乐的时候，当我们被迫在iTunes以2美元每首的价格购买歌曲的时候，来使用Spotify吧。” - Tech Crunch 现在的Spotify是一款极其梦幻的产品 。但它并不是一开始就这样的。我过去很幸运能够很早就参与到这个令人惊叹的历程中（现在仍是）。 Spotify启动于2006年，产品建立在一些关键的假设上——人们更喜欢流式音乐（而非下载到本地），唱片公司和艺术家们都愿意让人们合法地收听流式音乐，并且快速、稳定的流媒体在技术上是可行的。请注意，这是在2006年，听流式音乐（类似于Real Player）的体验仍然非常糟糕的，而对音乐进行盗版复制也几乎是常态。技术上的挑战是：“是否有可能制作这样一个客户端，当你按下播放按钮时，立刻就能播放流音乐？是否有可能摆脱那个可恶的“缓冲”进度条？”。 小起点并不意味着不可以有大抱负。这里是早期他们心目中的一篇草稿： 但开发者们并没有花几年去构建一款完整产品，然后再去确认假设是否仍然成立；而基本上只是坐下来建立一个技术原型，把时间花在任何便携式电脑上播放不流畅的音乐上，开始进行各种试验以找到实现快速而稳定播放的方法。驱动的度量指标是：“从按播放键到听到音乐要消耗多少微秒”。播放应该是非常即时的，并且持续播放应该流畅无停顿。 “当别人不关注的时候，我们却花了巨量的时间来专门处理延时问题；因为我们有着该死的癖好——想让你感觉就像是把全世界所有的音乐都装进了你的硬盘。专注于微小的细节有时候却能够产生巨大的差异。我认为，对最小可行产品概念的最大误解是在MVP的V上”。 - Daniel Ek，联合创始人兼首席执行官 一旦有什么像样的东西，他们就会开始在自己、家庭和朋友中进行体验。 初始版本也不可能发布给更广泛的受众，因为它完全未经打磨，并且除了能够查找和播放少数硬编码音乐外，基本没有什么其他特性，也没有任何合法协议或者经济模式。这就是他们的滑板版本。 但他们厚脸皮地把滑板版本交到了真实用户——朋友和家人们——的手中，并且快速得到了他们需要的答案。是的，在技术上是可行性。并且，是的，人们非常喜欢这个产品（或更喜欢修改后的产品）！假设得到了验证！这种可运行的原型帮助说服了唱片公司和投资人，其他的事情就众所周知了。 第2个例子：Minecraft游戏 Minecraft是在游戏开发史上最成功的游戏之一，如果考虑开发成本就更是如此。Minecraft也是尽早发布和频繁发布理念的最极端例子之一。只经过了一个人的6天编码，就制作和公开发布了第一个版本。第一个版本基本上干不了什么事情——基本上它就是一个丑陋的块状3D景观，你可以把方块挖出来，放在其他地方，去建造粗糙的建筑。 那就是滑板版本。 然而用户却被强烈吸引住了（大部分开发者与用户间的通信都是通过Twitter进行的，相当有趣）。早期的用户中就有我和我的四个孩子。仅在第一年里，就有超过一百个版本被制作和发布。游戏开发至始至终都在寻找玩点（在一些游戏公司，我曾在工作中使用术语“玩点的定义（Definition of Fun）”来替代“完成的定义（Definition of Done）”），而寻找玩点的最好方法就是找真人真地玩游戏–在本案例中，竟然有数千名真人花钱来试玩早期评估版本，因此他们也有动机去帮助改进游戏。 渐渐地，围绕这款游戏，形成了一个小小的开发团队（实际上大多数情况下只有2个人），而这款游戏在全世界则成为了一个大热门。我想我还没碰到过任何不玩Minecraft的孩子。并且去年（译者补充：是2014年11月）这款游戏（嗯，基于这款游戏，成立了一家公司）被微软公司以25亿美元的价格收购。太惊人。 第3个例子：大政府项目 大约2010年，为了能让警察把时间更多的花在现场而非警局，瑞典警方启动了一项重大举措——PUST（polisens utrednings STöD）。这是一个非常吸引人的项目，我作为教练参与，并写了一本关于我们做了什么以及学习到什么的书（《Lean from the Trenches》）。 产品的设计理念是在警车中配置便携式电脑，警察能够通过定制软件实时登录到所需的系统，例如在询问嫌犯的时候（这时候还属于平板电脑以前的时代） 过去他们曾试图建立类似的系统，但都不幸地失败了，主要是因为采用了大爆炸思维。他们告诉我，之前的一次尝试，从开始开发到发布首个版本，一共花了7年时间。七年！到发布的时候，当然什么都变了，所以这个项目彻底失败了。因此这次他们想换种方法来做。 这个60人的项目（后来被称为“PUST Java”）获得了惊人的成功，尤其是这还是一个大政府项目（它甚至在CIO奖项“年度项目”的评选中得到第二名）。这个项目成功的最主要因素之一，就是他们没有试图一次构建整个产品——他们把这个庞然大物从两个维度进行了拆分： 通过地区拆分。我们不需要一次发布就覆盖瑞典的所有地区，我们可以从只覆盖一个地区开始。 通过犯罪类型拆分。开始我们不需要支持所有的犯罪类型，我们可以从只支持1-2种犯罪类型开始。 第一个版本，1.0，就是他们的滑板版本。 这是一个小系统，只支持几种犯罪类型，由东约特兰省的少数几名警察进行现场体验。其它的犯罪类型处理时，仍然需要采用以往的方式——开车回到警局和做文书工作。他们知道自己在充当小白鼠，也知道产品还没有完成。但他们非常愿意去体验，因为他们清楚替代方案。他们过去也曾见识过那种缺乏早期用户反馈的过程中产出的系统有多么的蹩脚，现在他们终于有机会在构建过程中就对系统施加影响了！ 他们的反馈是严厉而又坦诚的。我们抛弃了很多假设，并出现了一个大的窘境——该如何处理那些精心制作的、但是随着真实用户反馈信息的到来而显得越来越没有意义的用例说明书（这是个有着瀑布历史以及习惯做大量的前期分析工作的组织）。 不管怎样，长话短说，早期反馈被用于产品改进，并且东约特兰省的那些警察逐渐开始喜欢上这款产品，我们现在可以添加更多的犯罪类型和扩展到更多的地区。到发布1.4这个大版本的时候，我们已经推广到全国范围并对12000警察进行了培训，而且对此我们毫不担忧。因为我们已经发布了这么多的版本，经过了这么多的用户体验，所以在对全国进行发布的那天晚上，我们都睡得很安稳。 不幸的是，成功是短暂的。可能是由于老的习惯，接下来的项目（PUST Siebel）却回到了瀑布思想，并且搞砸了。下一代产品在没有任何发布和用户体验情况下，在为期2年的分析和测试之后，向12000名警察进行了一次大爆炸发布。这绝对是一场灾难，经过半年的折腾之后，他们关闭了整个项目。开发成本约为2000万欧元，但内部的研究估计，瑞典的社会成本（因为糟糕的系统给警察工作造成了障碍）相当于10亿欧元！ 真是极其昂贵的学习方法！第4个例子：乐高 现在我在乐高工作，我对他们年复一年从不失败地发布新亮点的能力赞赏不已。关于他们如何做到这一点，我听到过很多有趣的故事，共同的主题都是要做原型和早期用户体验！我经常在办公室看到一群群的孩子，设计师与当地的幼儿园、学校和家庭合作，现场体验新产品的设计理念。 这是一个最近的例子– nexo knights （2016年1月发布的）： 当他们第一次开始探索概念的时候，他们制作了纸上原型并交给孩子们。孩子们的第一反应是：“嘿，谁是坏人？我看不出谁好谁坏！”哎呀。因此，设计师们不断迭代，直到他们找到一个对孩子们有用的设计方案。我打赌，甚至连你都能看出上图中谁好谁坏…… 在本故事中，无法精确辨别哪个是滑板版本，但是你收获了理念——来自真实用户的早期反馈！不要只进行设计和完整构建产品。想象一下，如果他们只是基于他们最初的设计假设去构建产品，在向全世界的商店发出几千箱货物后才学习到存在什么问题，会有什么的结果！ 乐高也曾经历过惨重的失败。乐高宇宙（Lego Universe）就是个例子，这是一款大型的、多玩家的、在线的乐高世界。听起来好玩吧？问题是，他们野心太大了，结果终结于试图在发布前就完美构建出所有事物。 大概有250个人，工作了4-5年（由于完美主义导致了持续的项目范围蔓延）。当最终发布版本时，却遭到了…冷遇。最终完成的游戏很漂亮，但并不如预期的那样好玩，因此2年后这款产品被关闭了。 没有滑板版本！ 为什么没有？因为滑板版本不够好（至少当你期望得到汽车时不够好），而乐高的文化完全是追求提供完美的用户体验！如果你在丹麦比隆的乐高总部工作，你每天都会走过下面这幅巨大的壁画： 可以粗略翻译成“只有最好才是足够好”。自从80年前公司成立以来，这一直是乐高的指导方针，并帮助他们成为世界上最成功的公司之一。但在本案例中，这个原则被误用。 对完美的追求耽误了获取至关重要的反馈，这意味着对用户的喜好做错误的假设。而这与Minecraft的工作方法正好相反。 十分有趣的是，乐高宇宙的开发团队其实是在严格地使用Scrum和迭代——与Minecraft团队的做法非常类似。但只进行内部发布，滑板版本、自行车版本等等十之八九是有的，但那些产品从未到达过真实用户。这就不是Scrum所预期的使用方法了。 是一个昂贵的失败，但乐高从中吸取了教训，并在早期体验和用户反馈上越做越好。 对“MVP”的改进 让我们深吸一口气，讨论下MVP（最小可行产品）这个话题。 背后的理念是伟大的，但这个术语本身却会导致很多困惑和焦虑。我见过很多的客户说：“我没办法做MVP交付——那就是我要获得的最终交付。”大多数情况下，团队交付了所谓的MVP后，就快速转向下一个项目，给客户留下一个有问题的、未完成的产品。对某些客户来说，MVP=MRC(Minimum Releasable Crap，最小可发布废物) 我明白，我很清楚，这些问题来自于管理不善而非MVP这个术语，但是…这个术语本身会招致误解。对于“最小”和“可行”，仁者见仁、智者见智，这就带来了问题。 因此，这里换一种说法。 首先，用“早（Early）”替换“最小（Minimum）”。发布MVP背后的整个理念是要获得早期的用户反馈——通过提供一个最小产品而非完整产品，我们才能更早的得到反馈。 对你来说是“可行的”，对我来说却是“可怕的”。因此，那就是我们的第一个改变： 最小（Minimum）=&gt; 最早（Earliest） 下一步，删除单词“可行（Viable）”，因为这个词太模糊。对你来说是“可行的”，对我来说却是“可怕的”。有些人认为可行（Viable）就意味着“我可以体验和从中得到反馈”，其他一些人则认为可行（Viable）意味着“客户可以实际使用”。因此，让我们更明确地表述，把它分成三个不同的事物（可体验的（testable）/可使用的（usable）/令人喜爱的（lovable））： 最早可体验的产品是滑板版本或者公共汽车票版本——这是第一个客户可以实际用来做事情的发布版本。可能并不能解决他们的问题，但至少能引发某种反馈。我们非常清楚，学习是这个版本的主要目的，获得的任何实际客户价值都是红利。 最早可使用的产品可能是自行车。这是第一个早期用户愿意使用的发布版本。虽然离最终完成还差得远，可能也不讨人喜欢。但它确实让你的客户进入到比以前更有利的位置。 最早令人喜爱的产品可能是摩托车。这是第一个客户喜欢的、会告诉朋友的并且愿意为之买单的发布版本。虽然还是有很多的改进空间，我们仍然可能继续改变，例如变成飞机或别的什么。但我们已经实现了一个真正有销路的产品。 我考虑过增加一个更早的环节“最早可反馈的产品”，这基本上是一个纸面原型之类的东西，你可以用来从客户那里获得第一次反馈。但四个环节看起来太多了，而且“可反馈的”这个术语…嘿嘿。然而，这也是一个重要环节。有些人可能会把纸面原型称为最早可体验的产品，但我认为这取决于你如何定义“可体验的”。看看Martin的 MVP Guide ，可以学到更多——他有大量超级具体的例子说明了如何以最小的投入来获得早期反馈。 当然，人们可能会误解“最早可体验的/可使用的/令人喜爱的”，但这个说法至少比模糊的“最小可行产品”更加明确。 关键点 OK，到总结的时候了。没想到篇幅会这么长，感谢你的坚持！关键点： 对于复杂、创新的产品开发，要避免大爆炸交付。你已经知道迭代和增量开发了，但你实际上真是这么做的吗？ 从识别滑板版本开始——最早可体验的产品。可以志存高远，但要收起你的骄傲，从交付滑板版本开始。 避免使用术语MVP。实际谈论的要使用更加具体的语言。最早可体验的/可使用的/令人喜爱的只是一个例子，也可以使用其他任何不会对你的相干关系人造成困惑的术语。记住–滑板/汽车图只是一个隐喻。别把它当真。:o) PS——这里有个有趣的故事，是关于我和我的孩子们如何使用这些概念来赢得机器人相扑比赛 。:o) 感谢Mary Poppendieck, Jeff Patton, Alistair Cockburn, Anders Haugeto, Sophia, 以及其他Crisp, Spotify and Lego的同事，以及其他所有提供了很多有用反馈的人。","categories":[{"name":"敏捷","slug":"敏捷","permalink":"www.hicoder.com.cn/categories/%E6%95%8F%E6%8D%B7/"},{"name":"精益","slug":"敏捷/精益","permalink":"www.hicoder.com.cn/categories/%E6%95%8F%E6%8D%B7/%E7%B2%BE%E7%9B%8A/"}],"tags":[{"name":"敏捷","slug":"敏捷","permalink":"www.hicoder.com.cn/tags/%E6%95%8F%E6%8D%B7/"},{"name":"精益","slug":"精益","permalink":"www.hicoder.com.cn/tags/%E7%B2%BE%E7%9B%8A/"},{"name":"MVP","slug":"MVP","permalink":"www.hicoder.com.cn/tags/MVP/"}]},{"title":"量化定投，工薪族逆袭之路","slug":"量化定投，工薪族逆袭之路","date":"2020-05-04T02:12:31.000Z","updated":"2020-05-10T07:44:38.880Z","comments":true,"path":"2020/05/04/量化定投，工薪族逆袭之路/","link":"","permalink":"www.hicoder.com.cn/2020/05/04/%E9%87%8F%E5%8C%96%E5%AE%9A%E6%8A%95%EF%BC%8C%E5%B7%A5%E8%96%AA%E6%97%8F%E9%80%86%E8%A2%AD%E4%B9%8B%E8%B7%AF/","excerpt":"一个人一生能积累多少钱，不是取决于他能够赚多少钱，而是取决于他如何投资理财，人找钱不如钱找钱，要知道让钱为你工作，而不是你为钱工作。——（美）沃伦●巴菲特","text":"一个人一生能积累多少钱，不是取决于他能够赚多少钱，而是取决于他如何投资理财，人找钱不如钱找钱，要知道让钱为你工作，而不是你为钱工作。——（美）沃伦●巴菲特 1234567891011# 导入常用的库import numpy as npimport pandas as pd import datetime as dtimport timeimport matplotlib.pyplot as pltimport seaborn as snsfrom jqdata import *import tushare as tsimport seaborn as snsplt.style.use('fivethirtyeight') 一、指数格局，跌宕起伏这里的指数，我们重点说一下上证指数、深圳指数。指数其实是一篮子股票，它反应的这些股票总体的表现。而上证与深圳指数更反应出当下国内的经济形式（当然不是百分百的呈现）。 相信大家都了解过经济周期，理论上，社会环境的经济会以衰退－萧条－复苏－繁荣四种形式往复呈现。不过，由于不同国家的国情不尽相同，这种周而复始的周期曲线表现得并不完美。 下图为经济周期曲线图： 那么，股市是否也会呈现一定的周期性呢？如果具有周期性，如何估算牛熊之间的时间距离呢？带着这样的疑问，接着往下探究。 在探究此问题之前，可以去查找一下相关的历史资料，看看是否有人已经给出答案，或者可以找一些重要的线索。经过百度，收集到：上证指数1990年12月19号成立，之后的经历了4次牛市，分别1993年2月、2001年6月、2007年10月、2015年6月。让我们来实际看一下上证指数全部的趋势情况。 1234567891011121314151617181920212223242526plt.style.use('fivethirtyeight')# 由于数据量比较多，这里打算从 tushare 获取上证指数所有的价格数据# tushare 接口，参数为注册时生成的 tokenpro = ts.pro_api('xxxxxxxxx')# tushare 要求一次最多获取 3000 条数据，所以分两次获取# 然后将数据合并，按时间排序df1 = pro.index_daily(ts_code='000001.SH', start_date='19901219', end_date='20101231')df2 = pro.index_daily(ts_code='000001.SH', start_date='20110101', end_date='20190630')df = pd.concat([df2, df1]) # 合并df = df.sort_values(by=['trade_date']) # 排序df['trade_date'] = pd.to_datetime(df['trade_date']) # 转换为时间类型df.set_index(['trade_date'], inplace=True) # 设置索引列df.index.name = None # 去掉索引列名# 将上证指数价格曲线画出来# 并在对应的牛市年份，画一条竖线来标记df.close.plot(figsize=(14, 7), title='牛顶间隔展示')for year in ['1993-02-01', '2001-06-01', '2007-10-01', '2015-06-01']: plt.axvline(year,color='r', alpha=0.7)plt.show() 看完这张图，大概大家都会感慨：曾经的股市是多么的疯狂，它也像人生，起起伏伏。粗一看，感觉指数的起伏是有一定的周期性规律可寻的，但仔细看却发现，各牛市间的时间间隔并不匀称。那问题来了，各牛市顶点的时间间隔大概在什么样的取值范围呢？未来大盘的趋势是否会符合某种规律呢？接下来我们计算一下各牛顶时间节点的平均间隔时间与偏差。 1234567891011121314151617181920212223242526# 转换成时间格式best_years = [dt.datetime.strptime(year, '%Y-%m-%d').date() for year in ['1993-02-01', '2001-06-01', '2007-10-01', '2015-06-01']]# 计算牛顶时间间隔gap_year = [days.days for days in np.diff(best_years)]print('牛顶平均间隔时间：', ['&#123;&#125; days'.format(days) for days in gap_year])# 计算平均间隔年数，为避免盲目猜测，再计算出均值的偏差值mean_gap = np.mean(gap_year)print('平均时间间隔 &#123;&#125; 天，即 &#123;&#125; 年'.format(round(mean_gap, 2), round(mean_gap / 365, 2)))# 计算平均时间间隔偏差值std_gap = np.std(gap_year)print('平均时间间隔偏差 &#123;&#125; 天，即 &#123;&#125; 年'.format(round(std_gap, 2), round(std_gap / 365, 2)))# 计算下一个牛市出现的合理时间区间early_year = (best_years[-1] + dt.timedelta(round(mean_gap - std_gap, 0)))latest_year = (best_years[-1] + dt.timedelta(round(mean_gap + std_gap, 0)))# 构造 titleearly_y = early_year.yearearly_m = early_year.monthlatest_y = latest_year.yearlatest_m = latest_year.monthprint('下个牛顶时间范围 &#123;&#125;年&#123;&#125;月 ~ &#123;&#125;年&#123;&#125;月'.format(early_y, early_m, latest_y, latest_m)) 牛顶平均间隔时间： [&apos;3042 days&apos;, &apos;2313 days&apos;, &apos;2800 days&apos;] 平均时间间隔 2718.33 天，即 7.45 年 平均时间间隔偏差 303.16 天，即 0.83 年 下个牛顶时间范围 2022年1月 ~ 2023年9月123456789101112title = '评估下个牛顶时间范围 &#123;&#125;年&#123;&#125;月 ~ &#123;&#125;年&#123;&#125;月'.format(early_y, early_m, latest_y, latest_m)df.close.plot(figsize=(14, 7), title=title)for year in ['1993-02-01', '2001-06-01', '2007-10-01', '2015-06-01']: plt.axvline(year,color='r', alpha=0.6) # 生成 2019-02-11 ~ 2023-12-10 的时间区间# 如果要填充一个区间，y 就给价格的最大值便好date_span = pd.date_range(early_year, latest_year)value_span = [df.close.max() for x in date_span]plt.fill_between(date_span, value_span, color='orange', alpha=0.8)plt.show() 这里需要提醒一下大家：历史数据只可用来评估一些现象，但绝不能 100% 预言未来！所以大家还要带着辩证的心态看待这个结果。 通过上面的统计与可视化，可得出以下结论： 一轮牛熊的平均时间间隔为7.5年左右； 4轮牛熊的时间偏差在0.8年左右； 依此估算的下个牛顶的时间范围在2022年1月 ~ 2023年9月之间。 假设这个结果是大概率可信的，那在到达牛顶之前，一定要经过一个牛市的启动阶段——所以，低估值与熊之尾巴才是最宝贵的！！！ 二、定投畅想，看好国运指数的价格一直在波动起伏，但从宏观看来，其底部是一直在抬高的。只要国家经济一直是向好的，那指数的从超长期来看，是总体向上发展的。也就是说，买指数产品，就是看好国运！ 例如下图，通过线性回归，我们可以看出，上证指数的价格整体趋势是向上的。假如在上证指数成立之初我们就买入，并一直持有到现在，到目前为止的收益将是多少呢？我们来做个计算。 1234# 通过线性回归，刻画整体平均趋势plt.figure(figsize=(14, 7))sns.regplot(x=np.arange(0, df.shape[0]), y=df.close.values)plt.show() 1234567891011121314151617181920# 为了计算方便，默认都倩收盘价格为准# 获取上市第一天的收盘价和当前收盘价start_price = df.close[0]end_price = df.close[-1]print('最初收盘价为 &#123;&#125;，当前收盘价为 &#123;&#125;'.format(start_price, end_price))# 计算收益率total_return = (end_price / start_price) - 1print('持有到目前为止的收益率为 &#123;&#125;%'.format(round(total_return * 100, 2)))# 计算年平均收益，一年以250个交易日为准# 平均年化收益率=(投资内收益/本金)×（250/投资天数）× 100%mean_return = total_return * (250 / df.shape[0])print('平均每年收益率为 &#123;&#125;%'.format(round(mean_return * 100, 2)))# 计算年化收益率复利# 本息和 = 本金 * （年化利率 + 1）的 n 次方，n为交易年数# 年化利率 = （本息和 / 本金）的 n次开根 - 1annualized_return = pow((end_price / start_price), 1 / (df.shape[0] / 250)) - 1print('年化收益率为 &#123;&#125;%'.format(round(annualized_return * 100, 2))) 最初收盘价为 99.98，当前收盘价为 2978.8784 持有到目前为止的收益率为 2879.47% 平均每年收益率为 103.22% 年化收益率为 12.94%看到这里，可能小伙伴们都张大了嘴大喊：“这不可能！我不相信！”是的，12.9% 的年化复利，的确很夸张。但这并不是表明指数收益相当可观，这其中的原因是： 指数刚上市的时候净值很低； 中国的经济已经发生了天翻地覆的变化； 持有的时间相对长； 没有考虑通货膨胀与金钱的时间价值。 现在我们已经知道，指数从长期来看是持续向上发展的，而在指数投资中，越早投资获得的收益越好。但对于大部分的式蒺族来说，大家的理财理念并没有得到较好的普及，况且投资是一项需要承担较高风险的活动，许多工薪族朋友只能看着自己的钱包在非理性消费与通货膨胀的影响下不断的缩水。有些拥有比较好的习惯的工薪族会将部分收入储蓄到银行卡中，但仍旧逃不过金钱被贬值的命运！ 其实，工薪族如果了解“定投”这个概念的话，是可以将一部分的资金从银行卡里拿出来定期存到指数投资产品中的。如果去百度定投的概念，那么会出现一些关键字，比如“低估值”，“风险平摊”，“定期定额度”，“微笑曲线”等，如果对于定投不太了解，可以先去百度一下定投的理念。 接下来，我们构建一个以定期定额方式投资指数的模型，看看最终的投资效果如何。 模型描述： 最早日期选定在上证指数公布的那一天； 每月的第一个交易日买入上证指数1000元； 假设指数的净值已经缩小到个位数,即 1000 元可以正常交易； 持有到现在，没有卖出。 本模型不考虑交易费用与滑点，默认每次的投入本金都可以全部买进！ 12345678910111213# 获取每个月的第一个交易日的数据first_day = []for i in range(len(df)): date = df.index[i] if i == 0: first_day.append(date) else: last_date = df.index[i - 1] if date.day &lt; last_date.day: first_day.append(date) index_df = df.loc[first_day]index_df.index DatetimeIndex([&apos;1990-12-19&apos;, &apos;1991-01-02&apos;, &apos;1991-02-01&apos;, &apos;1991-03-01&apos;, &apos;1991-04-01&apos;, &apos;1991-05-02&apos;, &apos;1991-06-03&apos;, &apos;1991-07-01&apos;, &apos;1991-08-01&apos;, &apos;1991-09-02&apos;, ... &apos;2018-09-03&apos;, &apos;2018-10-08&apos;, &apos;2018-11-01&apos;, &apos;2018-12-03&apos;, &apos;2019-01-02&apos;, &apos;2019-02-01&apos;, &apos;2019-03-01&apos;, &apos;2019-04-01&apos;, &apos;2019-05-06&apos;, &apos;2019-06-03&apos;], dtype=&apos;datetime64[ns]&apos;, length=343, freq=None)12345678910111213141516171819# 按照模型进行定投month_df = index_df.copy()month_df['pct_change'] = month_df['close'].pct_change()month_df = month_df[['close', 'pct_change']] # 按月整合数据save_money = []hold_money = []save_base = 1000for i in range(len(month_df)): if i == 0: save_money.append(save_base) hold_money.append(save_base) else: save_money.append(save_money[-1] + save_base) hold_money.append(hold_money[-1] * (1 + month_df['pct_change'][i]) + save_base)month_df['save_money'] = save_moneymonth_df['hold_money'] = hold_moneymonth_df.head(10) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } close pct_change save_money hold_money 1990-12-19 99.98 NaN 1000 1000.000000 1991-01-02 128.84 0.288658 2000 2288.657732 1991-02-01 129.51 0.005200 3000 3300.559320 1991-03-01 132.53 0.023319 4000 4377.523950 1991-04-01 120.73 -0.089036 5000 4987.764781 1991-05-02 113.16 -0.062702 6000 5675.022468 1991-06-03 115.97 0.024832 7000 6815.945172 1991-07-01 136.85 0.180047 8000 9043.132679 1991-08-01 145.24 0.061308 9000 10597.549071 1991-09-02 180.22 0.240843 10000 14149.891858 12345678910# 计算定投、收益曲线month_df['return_money'] = month_df['hold_money'] - month_df['save_money']month_df[['save_money', 'hold_money', 'return_money']].plot(figsize=(14, 7))plt.legend(['累积投入', '累积本息', '累积收入'])plt.show()print('累计投入: &#123;&#125;元'.format(month_df['save_money'][-1]))print('累计收益: &#123;&#125;元'.format(month_df['return_money'][-1]))print('最终本息累积: &#123;&#125;元'.format(month_df['hold_money'][-1]))print('绝对收益率为: &#123;&#125;%'.format((month_df['return_money'][-1] / month_df['save_money'][-1]) * 100)) 累计投入: 343000元 累计收益: 583956.3789768222元 最终本息累积: 926956.3789768222元 绝对收益率为: 170.24967317108522%三、指数分析，知已知彼从上面的模型可以看出，如果尽早的定投，并且在低估的时候开始定投，随着国家的发展，指数的不断攀升，累积的总体收益也是一直在上升的。虽然总体收益率不是很高，但在2015的时候，总资金曾达到160万左右。 由于此模型没有卖出，因此在牛市疯狂的时候，没有到盈利落实到口袋中，而在市场最高的位置，也在不断的投入资金，这样便将定投的平均成本摊高了。 因此，接下来我们想解决的问题是，能否在指数位置偏低的时候持续定投，而在指数位置走到某种高度以上时持续卖出呢？那用什么指标来评判指数的高低位置呢？ 了解点价值投资者的朋友，都应该听说过 PE 和 PB，它们可以用来评估标的价格是处于低估还是高估位置。因此，下面我们将 PE 和 PB 运用到指数上来，看看能否带来效果。 下面使用简单的中位数方式，求取指数每天的PE与PB。 1234567891011121314151617181920212223242526272829303132333435363738# 从聚宽获取上证指数的信息index = '000001.XSHG' # 指数 codeindex_info = get_security_info(index) # 指数信息start_date = index_info.start_date # 指数开始时间end_date = datetime.datetime.now().date() # 以当天为最后一天index_name = index_info.display_name # 指数全称# 定义一个函数，计算每天的成份股的平均pe/pbdef get_pe_pb(index_code, start_date, end_date): def iter_pe_pb(): # 一个获取PE/PB的生成器 trade_date = get_trade_days(start_date=start_date, end_date=end_date) for date in trade_date: stocks = get_index_stocks(index_code, date) q = query(valuation.pe_ratio, valuation.pb_ratio ).filter(valuation.pe_ratio != None, valuation.pb_ratio != None, valuation.code.in_(stocks)) df = get_fundamentals(q, date) # 通过分位值进行过滤异常值 # 这里并没有采用三倍标准差来去除极值，差异不大 quantile = df.quantile([0.25, 0.75]) df_pe = df.pe_ratio[(df.pe_ratio &gt; quantile.pe_ratio.values[0]) &amp;\\ (df.pe_ratio &lt; quantile.pe_ratio.values[1])] df_pb = df.pb_ratio[(df.pb_ratio &gt; quantile.pb_ratio.values[0]) &amp;\\ (df.pb_ratio &lt; quantile.pb_ratio.values[1])] yield date, df_pe.median(), df_pb.median() dict_result = [&#123;'date': value[0], 'pe': value[1], 'pb':value[2]&#125; for value in iter_pe_pb()] df_result = pd.DataFrame(dict_result) df_result.set_index('date', inplace=True) return df_resultdf_pe_pb = get_pe_pb(index, start_date, end_date)df_pe_pb.head(10) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } pb pe date 2005-01-04 2.01585 26.53715 2005-01-05 2.04450 26.94350 2005-01-06 2.02165 26.61115 2005-01-07 2.02360 26.77050 2005-01-10 2.04630 26.94320 2005-01-11 2.05100 26.99430 2005-01-12 2.04245 26.78615 2005-01-13 2.06330 26.81250 2005-01-14 2.02760 26.63980 2005-01-17 1.96960 25.85190 123# 可视化PE/PB曲线图df_pe_pb.plot(figsize=(14, 7), subplots=True)plt.show() 12345678910# 将PE/PB趋势与指数趋势一起展示，以作观察_, axs = plt.subplots(ncols=2, figsize=(14, 5))close = get_price(index, start_date=start_date, end_date=end_date).close_df = pd.DataFrame()_df['close'] = close_df['pe'] = df_pe_pb.pe_df['pb'] = df_pe_pb.pb_df[['close', 'pe']].plot(secondary_y=['pe'], ax=axs[0], alpha=.8)_df[['close', 'pb']].plot(secondary_y=['pb'], ax=axs[1], alpha=.8)plt.show() 如上图所示，可以看出，PE 与 PB 的大小会随着市场的起伏而呈现正相关性的波动。PE 的波动区间大概在 10 到 70 倍之间，而 PB 的波动范围大概在 0 到 7 之间。 1234567# 分析PE/PB数据分布情况_, axs = plt.subplots(nrows=2, ncols=2, figsize=(14, 7))sns.distplot(df_pe_pb.pe, ax=axs[0][0])sns.boxplot(df_pe_pb.pe, ax=axs[0][1])sns.distplot(df_pe_pb.pb, ax=axs[1][0])sns.boxplot(df_pe_pb.pb, ax=axs[1][1])plt.show() 这里，通过上图的正态分布图与箱线图可以看出，PE 与 PB 有两个峰值，PE 的值主要集中在 2439 倍区间，PB 的值主要集中在 2.13.6 倍之间。 另外，牛市顶时对就的 PE 与 PB 值数量相当少，并且与中间区间的值的距离相对比较远，以至于在箱线图上成为了离群点。通过这一点可以说明牛市顶一闪而过，时间非常短，产生的数据量也非常少。 整体来说，上图反应了中国股市熊长牛短的特点。因此，想要抓住牛市的机会，是需要而心等待的。 123# 观察PE/PB之间的关系sns.jointplot(x='pb',y='pe', data=df_pe_pb, height=7)plt.show() PE 与 PB 都可以用来对指数进行估值，那到底用哪个比较好呢？ 但通过上图的散点图发现，本研究对应的 PE 与 PB 数据存在线性相关的数据，也就是说这两个指标大致上是同步涨同步跌的，因此，无论用 PE 还是 PB 来进行估值，效果都差不多，因此，接下将使用 PE 进行高位位置的判断。 123456789# 将PE分成十个分位，查看各分位PE数量pe_array = df_pe_pb.pe.valuesvalue_counts = pd.cut(pe_array, 10).value_counts()print(value_counts)plt.figure(figsize=(14, 4))sns.barplot(x=np.arange(0, len(value_counts)), y=value_counts.values)plt.show() (15.708, 21.447] 248 (21.447, 27.129] 1170 (27.129, 32.811] 523 (32.811, 38.492] 757 (38.492, 44.174] 490 (44.174, 49.856] 118 (49.856, 55.538] 100 (55.538, 61.219] 103 (61.219, 66.901] 25 (66.901, 72.583] 12 dtype: int64 上图是将 PE 的值分成了 10 个分位，对每个分位 PE 的数量进行统计，可是以发现： 第 2 个柱体是最高的，说明第 2 个 10 分位的 PE 数据量最多。 整体上来看，柱状图呈左偏形态，说明 PE 长时间处于 5 分位以下。 第 9 与第 10 个柱体代表的量少得可怜，说明高估值区的时间非常短。 123456789101112131415161718# 刻画PE整体趋势的中等分位区间（40%~60%）def show_quantile(): _df = pd.DataFrame() df = df_pe_pb.copy() df.index.name = None _df['pe'] = df.pe _df = _df p_high = [_df.pe.quantile(i / 10.0) for i in [4, 5, 6]] for p_h, i in zip(p_high, [4, 5, 6]): _df[str(i / 10 * 100)+'%'] = p_h low_p = _df[_df.pe &lt; _df.pe.iloc[-1]] quantile_now = low_p.shape[0] / _df.shape[0] # 当前百分位值 last_p = _df.pe[-1] _df.plot(figsize=(14, 7))show_quantile() 上图将当前 PE 按时间序列进行可视化，并用三条线标出了 40%、50%、60% 分位的位置。再结合上面的统计，可以得出： 低估区的数据数量为：2686 估值适中区的数据数量为：608 高估区的数据数量为：240 比值为 2684:608:240。低估区间的时间是高估区时间的11.19倍。 12345# 计算比值low = value_counts[0:4].sum()medin = value_counts[4:6].sum()high = value_counts[6:10].sum()print('比值(&#123;&#125;：&#123;&#125;：&#123;&#125;)'.format(low, medin, high)) 比值(2698：608：240)四、模型构思，循序渐进由于PE/PB数据是从聚宽数据而来，最早的时间是2005年的数据，因此，相较于1990年的数据来说，数据量减少了不止一点。但不影响接下来的研究。 通过上面的分析，接下来提出的设想是：设定一个可参考的估值区，当小于该估值时，进行定投，反之则持续卖出。 上面我们已经计算出，PE 40 到 60 的估值范围为 32.811 ~ 49.856 之间，这里我们设定此区间为适中估值区间。 模型的描述如下： 当 PE 处于适中估值区间时，不做任何操作；当月准备的定投金归入回收资金中。 当 PE 低于适中估值区间时，持续定投。 当 PE 高于适中估值区间时，持续卖出；卖出的金额与当月准备的定投金归入回收资金中。 本模型不考虑交易费用与滑点，默认每次的投入本金都可以全部买进！ 123456789101112131415161718# 获取每个月的第一个交易日first_day = []for i in range(len(df_pe_pb)): date = df_pe_pb.index[i] if i == 0: first_day.append(date) else: last_date = df_pe_pb.index[i - 1] if date.day &lt; last_date.day: first_day.append(date)# 按月计算价格与涨跌幅度close = get_price(index, start_date=df_pe_pb.index[0], end_date=df_pe_pb.index[-1])['close']df = df_pe_pb.copy()df['close'] = closedf = df.loc[first_day]df['pct_change'] = df.close.pct_change()df.head(10) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } pb pe close pct_change date 2005-01-04 2.01585 26.53715 1242.77 NaN 2005-02-01 1.86520 24.02880 1188.93 -0.043323 2005-03-01 2.09300 26.67730 1303.41 0.096288 2005-04-01 1.86500 25.19810 1223.57 -0.061255 2005-05-09 1.59800 22.17390 1130.84 -0.075786 2005-06-01 1.57390 20.97550 1039.19 -0.081046 2005-07-01 1.55790 21.28340 1055.59 0.015782 2005-08-01 1.49010 20.81670 1088.95 0.031603 2005-09-01 1.71190 22.38690 1184.93 0.088140 2005-10-10 1.69390 22.21185 1138.95 -0.038804 1234567891011121314151617181920212223242526272829303132333435363738394041miden_estimation = (38.492, 49.856) # 中等估值的pe区间save_money = [] # 每月定存back_money = [] # 回收资金hold_money = [] # 持仓资金base_money = 1000 # 定投基准def trade(): for i in range(len(df)): pe = df['pe'][i] # 估值位 if i == 0: # 初始买入 # 1.计算买入金额 save_money.append(base_money) # 2. 计算回收金额 back_money.append(0) # 3. 计算持仓变化 hold_money.append(base_money) continue if pe &lt;= miden_estimation[0]: # 执行买入计算 # 1.计算买入金额 save_money.append(base_money) # 2. 计算回收金额 back_money.append(0) # 3. 计算持仓变化 hold_money.append(hold_money[-1] * (1 + df['pct_change'][i]) + base_money) elif pe &gt;= miden_estimation[-1]: # 执行卖出计算 # 1. 计算买入金额 save_money.append(0) # 2. 计算回收金额 back_money.append(base_money) # 3. 计算持仓变化 hold_money.append(hold_money[-1] * (1 + df['pct_change'][i]) - base_money) else: # 1.计算买入金额 save_money.append(0) # 2. 计算回收金额 back_money.append(0) # 3. 计算持仓变化 hold_money.append(hold_money[-1] * (1 + df['pct_change'][i]))trade() 12345678910111213141516df['save_money'] = save_money # 定投金额df['save_money_cumsum'] = df['save_money'].cumsum() # 定投累计金额df['hold_money'] = hold_money # 持仓金额df['back_money'] = back_money # 回收金额df['back_money_cumsum'] = df['back_money'].cumsum() # 累计回收金额df['total_money'] = df['hold_money'] + df['back_money_cumsum'] # 总资金df['return_money'] = df['total_money'] - df['save_money_cumsum'] # 持续收益df['return_rate'] = (df['total_money'] / df['save_money_cumsum']) - 1 # 持续收益率df[['save_money_cumsum', 'total_money', 'back_money_cumsum', 'return_money']].plot(figsize=(14, 7))plt.legend(['累积定投', '累计本息', '回收资金', '收益曲线'])plt.show()print('累计投入: &#123;&#125;元'.format(df['save_money_cumsum'][-1]))print('累计收益: &#123;&#125;元'.format(df['return_money'][-1]))print('最终本息累积: &#123;&#125;元'.format(df['total_money'][-1]))print('绝对收益率为: &#123;&#125;%'.format((df['return_money'][-1] / df['save_money_cumsum'][-1]) * 100)) 累计投入: 133000元 累计收益: 49155.86259384008元 最终本息累积: 182155.86259384008元 绝对收益率为: 36.95929518333841%12345678910111213141516171819# 展示各年投入金额money_year = &#123;&#125;for date in df.index: year = date.year if year in money_year.keys(): money_year[year] = money_year[year] + df.loc[date, 'save_money'] else: money_year[year] = df.loc[date, 'save_money'] money_mean = mean(list(money_year.values()))years_count = len(money_year) - 1money_year = &#123;key: [value] for key, value in money_year.items()&#125;df_money_year = pd.DataFrame(money_year, index=[''])df_money_year = df_money_year.Tdf_money_year.plot(figsize=(14, 4), kind='bar')plt.hlines(money_mean, 0, years_count, color='orange')plt.legend(['年均投入', '定投年金'])plt.show() 123456789101112# 展示各年的收益return_year = &#123;&#125;for date in df.index: year = date.year return_year[year] = df.loc[date, 'return_rate']return_year = &#123;key: [value] for key, value in return_year.items()&#125;return_df = pd.DataFrame(return_year, index=['return']).Treturn_df['diff'] = return_df['return'].diff()return_df['diff'].fillna(return_df['return'], inplace=True)return_df[['diff']].plot(figsize=(14, 4), kind='bar')plt.legend(['各年收益率'])plt.show() 从上面的模型来看，整个投资区间，回收资金过少，即不能很好的在市场上涨的时候将钱落袋为安。 由于买入与卖出都是按一个基准来操作的，因此，这里设想，是否可以越跌则买的越多，而越涨越卖出得越多呢？ 模拟描述： 当 PE 处于适中估值区间时，不做任何操作；当月准备的定投金归入回收资金中。 当 PE 低于适中估值区间时，持续定投；每低一个10%分位，则增加一倍倍投入。 当 PE 高于适中估值区间时，每高一个10%分位，则增加一倍卖出。在上面分析过程中发现低估值区间是高估值区间的11倍左右，因此，这里还在卖出的原倍数上乘以11. 本模型不考虑交易费用与滑点，默认每次的投入本金都可以全部买进！ 123456789101112131415161718# 获取每个月的第一个交易日first_day = []for i in range(len(df_pe_pb)): date = df_pe_pb.index[i] if i == 0: first_day.append(date) else: last_date = df_pe_pb.index[i - 1] if date.day &lt; last_date.day: first_day.append(date)# 按月计算价格与涨跌幅度close = get_price(index, start_date=df_pe_pb.index[0], end_date=df_pe_pb.index[-1])['close']df = df_pe_pb.copy()df['close'] = closedf = df.loc[first_day]df['pct_change'] = df.close.pct_change()df.head(10) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } pb pe close pct_change date 2005-01-04 2.01585 26.53715 1242.77 NaN 2005-02-01 1.86520 24.02880 1188.93 -0.043323 2005-03-01 2.09300 26.67730 1303.41 0.096288 2005-04-01 1.86500 25.19810 1223.57 -0.061255 2005-05-09 1.59800 22.17390 1130.84 -0.075786 2005-06-01 1.57390 20.97550 1039.19 -0.081046 2005-07-01 1.55790 21.28340 1055.59 0.015782 2005-08-01 1.49010 20.81670 1088.95 0.031603 2005-09-01 1.71190 22.38690 1184.93 0.088140 2005-10-10 1.69390 22.21185 1138.95 -0.038804 123456789def get_how_value(pe): how_value = [15.708,21.447,27.129,32.811,38.492,44.174, 49.856,55.538,61.219,66.901,72.583] for i, value in zip(range(0, len(how_value)) , how_value): # zip 包装了整数倍的分位值与对应的pe值区间 if how_value[i] &lt;= pe &lt; how_value[i + 1]: location = i + 1 _how_value = 5 - location # 以5为中等值 return _how_value # 返回基于中位的买入或卖出倍数 1234567891011121314151617181920212223242526272829303132333435miden_estimation = (38.492, 49.856) # 中等估值的pe区间save_money = [] # 每月定存back_money = [] # 回收资金hold_money = [] # 持仓资金base_money = 1000 # 定投基准def trade(): for i in range(len(df)): pe = df['pe'][i] # 估值位 how_value = get_how_value(pe) if i == 0: # 初始买入 # 1.计算买入金额 save_money.append(base_money) # 2. 计算回收金额 back_money.append(0) # 3. 计算持仓变化 hold_money.append(base_money) continue if how_value &gt; 0: # 执行买入计算 # 1.计算买入金额 save_money.append(base_money * how_value) # 2. 计算回收金额 back_money.append(0) # 3. 计算持仓变化 hold_money.append(hold_money[-1] * (1 + df['pct_change'][i]) + base_money * how_value) else: # 执行卖出计算 # 1. 计算买入金额 save_money.append(0) # 2. 计算回收金额 back_money.append(base_money * -how_value * 11) # 3. 计算持仓变化 hold_money.append(hold_money[-1] * (1 + df['pct_change'][i]) - base_money * -how_value * 11)trade() 12345678910111213141516df['save_money'] = save_money # 定投金额df['save_money_cumsum'] = df['save_money'].cumsum() # 定投累计金额df['hold_money'] = hold_money # 持仓金额df['back_money'] = back_money # 回收金额df['back_money_cumsum'] = df['back_money'].cumsum() # 累计回收金额df['total_money'] = df['hold_money'] + df['back_money_cumsum'] # 总资金df['return_money'] = df['total_money'] - df['save_money_cumsum'] # 持续收益df['return_rate'] = (df['total_money'] / df['save_money_cumsum']) - 1 # 持续收益率df[['save_money_cumsum', 'total_money', 'back_money_cumsum', 'return_money']].plot(figsize=(14, 7))plt.legend(['累积定投', '累计本息', '回收资金', '收益曲线'])plt.show()print('累计投入: &#123;&#125;元'.format(df['save_money_cumsum'][-1]))print('累计收益: &#123;&#125;元'.format(df['return_money'][-1]))print('最终本息累积: &#123;&#125;元'.format(df['total_money'][-1]))print('绝对收益率为: &#123;&#125;%'.format((df['return_money'][-1] / df['save_money_cumsum'][-1]) * 100)) 累计投入: 319000元 累计收益: 288684.23619299044元 最终本息累积: 607684.2361929904元 绝对收益率为: 90.49662576582772%12345678910111213141516171819# 展示各年投入金额money_year = &#123;&#125;for date in df.index: year = date.year if year in money_year.keys(): money_year[year] = money_year[year] + df.loc[date, 'save_money'] else: money_year[year] = df.loc[date, 'save_money'] money_mean = mean(list(money_year.values()))years_count = len(money_year) - 1money_year = &#123;key: [value] for key, value in money_year.items()&#125;df_money_year = pd.DataFrame(money_year, index=[''])df_money_year = df_money_year.Tdf_money_year.plot(figsize=(14, 4), kind='bar')plt.hlines(money_mean, 0, years_count, color='orange')plt.legend(['年均投入', '定投年金'])plt.show() 123456789101112# 展示各年的收益return_year = &#123;&#125;for date in df.index: year = date.year return_year[year] = df.loc[date, 'return_rate']return_year = &#123;key: [value] for key, value in return_year.items()&#125;return_df = pd.DataFrame(return_year, index=['return']).Treturn_df['diff'] = return_df['return'].diff()return_df['diff'].fillna(return_df['return'], inplace=True)return_df[['diff']].plot(figsize=(14, 4), kind='bar')plt.legend(['各年收益率'])plt.show() 模型有了很大的进步，总体说来，资金的增长主要靠的是持续的定投与高位的加倍卖出举动。 但该模型在使用了从过支到当下计算的估值区间，我们期望可以使用一种动态追踪的估值数字，来指导我们做定投。 设想：将表态的pe按照近一段时间，来评估当下pe占过去历史百分位的高度，此区间随着时间的移动，一来可以发生动态变化，二来可以不受太旧历史数据的影响。 那这个历史区间设置多久呢？在上面的计算中，我们发现一个牛熊的运动大概在7.5年左右。因此，我们在这里设置这个时间区间为7.5年。 来看看依照此方式计算出的结果： 123456789101112131415161718192021222324252627# 查看动态pe形态的分位趋势图def get_quantile(index_code, p, n, data): \"\"\"指数百分位展示。 Args: index_code: 指数 code。 p: 可以是 pe，也可以是 pb。 n: 指用于计算指数估值百分位的区间，如果是5指近5年数据。 data: 包含有 pe/pb 的 DataFrame。 Returns: 计算后的DataFrame。 \"\"\" # 这里的计算按一年244个交易日计算 windows = int(n * 244) # 将时间取整数 _df = data.copy() _df.index.name = None price = get_price(index_code, start_date=_df.index[0], end_date=_df.index[-1]) _df['close'] = price.close _df['quantile'] = _df[p].rolling(windows).apply(lambda x: pd.Series(x).rank().iloc[-1] / pd.Series(x).shape[0], raw=True) _df.dropna(inplace=True) _df['quantile'].plot(figsize=(14, 7)) # 画出适中估值区间 plt.fill_between(_df.index, y1=0.4, y2=0.6, color='orange', alpha=0.7) plt.annotate('适中估值区', (_df.index[-1], 0.5)) return _df# 展示指数百分位趋势图df_quantile = get_quantile(index, 'pe', 7.45, df_pe_pb) 12345678910111213141516171819202122232425# pe动态分位图与指数高低位的比较def show_quantile(index_code, p, n, data): \"\"\"指数百分位展示。 Args: index_code: 指数 code。 p: 可以是 pe，也可以是 pb。 n: 指用于计算指数估值百分位的区间，如果是5指近5年数据。 data: 包含有 pe/pb 的 DataFrame。 Returns: None. \"\"\" # 这里的计算按一年244个交易日计算 windows = int(n * 244) # 将时间取整数 _df = data.copy() _df.index.name = None price = get_price(index_code, start_date=_df.index[0], end_date=_df.index[-1]) _df['close'] = price.close _df['quantile'] = _df[p].rolling(windows).apply(lambda x: pd.Series(x).rank().iloc[-1] / pd.Series(x).shape[0], raw=True) _df.dropna(inplace=True) _df[['quantile', 'close']].plot(figsize=(14, 10), subplots=True) # 画出适中估值区间 # 展示指数百分位趋势图show_quantile(index, 'pe', 7.5, df_pe_pb) 由上我们可以看出，pe近7.5年的动态分位图可以比较恰当的描述指数的高低起伏。 由此作出以下模型构思。 模型描述： 以近7.5年的pe分位来指导定投操作； 当分位值低于适中估值区间时，按倍增法买入； 当分位值处于适中估值区间时，不做任何操作； 当分位值高于适中估值区间时，按照立方指数数倍卖出。 本模型不考虑交易费用与滑点，默认每次的投入本金都可以全部买进！ 123456789101112131415161718# 获取每个月的第一个交易日first_day = []for i in range(len(df_quantile)): date = df_quantile.index[i] if i == 0: first_day.append(date) else: last_date = df_quantile.index[i - 1] if date.day &lt; last_date.day: first_day.append(date)# 按月计算价格与涨跌幅度close = get_price(index, start_date=df_quantile.index[0], end_date=df_quantile.index[-1])['close']df = df_quantile.copy()df['close'] = closedf = df.loc[first_day]df['pct_change'] = df.close.pct_change()df.head(10) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } pb pe close quantile pct_change 2012-06-28 2.34595 23.62375 2195.84 0.201431 NaN 2012-07-02 2.41665 24.12060 2226.11 0.215190 0.013785 2012-08-01 2.23125 22.63260 2123.36 0.165107 -0.046157 2012-09-03 2.17690 21.89940 2059.15 0.114474 -0.030240 2012-10-08 2.20460 21.38255 2074.42 0.088608 0.007416 2012-11-01 2.16470 21.78270 2104.43 0.116676 0.014467 2012-12-03 1.82780 18.31150 1959.77 0.010457 -0.068741 2013-01-04 2.17510 21.58100 2276.99 0.112273 0.161866 2013-02-01 2.34590 23.32070 2419.02 0.219042 0.062376 2013-03-01 2.40170 24.69880 2359.51 0.270226 -0.024601 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748save_money = [] # 每月定存back_money = [] # 回收资金hold_money = [] # 持仓资金base_money = 1000 # 定投基准def trade(): for i in range(len(df)): quantile = df['quantile'][i] # 估值位 multiple = int((0.5 - quantile) * 10) # 定投倍数计算 if i == 0: # 初始买入 # 1.计算买入金额 _save_money = base_money * multiple save_money.append(_save_money) # 2. 计算回收金额 _back_money = 0 back_money.append(_back_money) # 3. 计算持仓变化 _hold_money = _save_money hold_money.append(_hold_money) continue if multiple &gt;=0: # 执行买入计算 # 1.计算买入金额 _save_money = base_money * multiple save_money.append(_save_money) # 2. 计算回收金额 _back_money = 0 back_money.append(_back_money) # 3. 计算持仓变化 _hold_money = hold_money[-1] * (1 + df['pct_change'][i]) + _save_money hold_money.append(_hold_money) else: # 执行卖出计算 # 1. 计算买入金额 _save_money = 0 save_money.append(_save_money) # 2. 计算回收金额 _back_money = base_money * (2 ** -multiple) # 按2的指数倍卖出 _hold_money = hold_money[-1] * (1 + df['pct_change'][i]) if _back_money &gt; _hold_money: _back_money = _hold_money if quantile &gt;= 1.0: _back_money = _hold_money # 如果达到100%分位，清仓 back_money.append(_back_money) # 3. 计算持仓变化 _hold_money = _hold_money - _back_money hold_money.append(_hold_money)trade() 12345678910111213141516df['save_money'] = save_money # 定投金额df['save_money_cumsum'] = df['save_money'].cumsum() # 定投累计金额df['hold_money'] = hold_money # 持仓金额df['back_money'] = back_money # 回收金额df['back_money_cumsum'] = df['back_money'].cumsum() # 累计回收金额df['total_money'] = df['hold_money'] + df['back_money_cumsum'] # 总资金df['return_money'] = df['total_money'] - df['save_money_cumsum'] # 持续收益df['return_rate'] = (df['total_money'] / df['save_money_cumsum']) - 1 # 持续收益率df[['save_money_cumsum', 'total_money', 'back_money_cumsum', 'return_money']].plot(figsize=(14, 7))plt.legend(['累积定投', '累计本息', '回收资金', '收益曲线'])plt.show()print('累计投入: &#123;&#125;元'.format(df['save_money_cumsum'][-1]))print('累计收益: &#123;&#125;元'.format(df['return_money'][-1]))print('最终本息累积: &#123;&#125;元'.format(df['total_money'][-1]))print('绝对收益率为: &#123;&#125;%'.format((df['return_money'][-1] / df['save_money_cumsum'][-1]) * 100)) 累计投入: 99000元 累计收益: 77142.48573219407元 最终本息累积: 176142.48573219407元 绝对收益率为: 77.92170275979198%12345678910111213141516171819# 展示各年投入金额money_year = &#123;&#125;for date in df.index: year = date.year if year in money_year.keys(): money_year[year] = money_year[year] + df.loc[date, 'save_money'] else: money_year[year] = df.loc[date, 'save_money'] money_mean = mean(list(money_year.values()))years_count = len(money_year) - 1money_year = &#123;key: [value] for key, value in money_year.items()&#125;df_money_year = pd.DataFrame(money_year, index=[''])df_money_year = df_money_year.Tdf_money_year.plot(figsize=(14, 4), kind='bar')plt.hlines(money_mean, 0, years_count, color='orange')plt.legend(['年均投入', '定投年金'])plt.show() 123456789101112# 展示各年的收益return_year = &#123;&#125;for date in df.index: year = date.year return_year[year] = df.loc[date, 'return_rate']return_year = &#123;key: [value] for key, value in return_year.items()&#125;return_df = pd.DataFrame(return_year, index=['return']).Treturn_df['diff'] = return_df['return'].diff()return_df['diff'].fillna(return_df['return'], inplace=True)return_df[['diff']].plot(figsize=(14, 4), kind='bar')plt.legend(['各年收益率'])plt.show() 由于采用了动态计算pe百分位高度的方式，又牺牲掉了7.5年时间的数据，因此这个模型的数据更少。 但通过观察，发现整体的收益很可观，再结果文章开始对于下个牛市的展望，我们可以期望在2021年左右，获得一次资产翻倍的机会。 另外，在定投的过程中，可以将加收的资金买入国债，以增加收益，如果经过了多轮牛熊后，更可以将回收的资金再次投入的下一次的定投中去，以达成在低估值区间买入更多份额的目标。 由于篇幅有限，这两种情况就不作演算了。 最后说一点，由于该模型是在历史几个牛熊数据上推理优化而得，因此，这是一个过拟合模型。但为何还要去研究呢？是因为，这一切都建立在指数有效的假设上。即：我们相信，中国的运势会越来越好，指数有低谷，也终将有高潮！ 接下来，我们将上面的模型尝试运用到沪深300指数上，检验一下效果。 12345678index = '000300.XSHG' # 指数 codeindex_info = get_security_info(index) # 指数信息start_date = index_info.start_date # 指数开始时间end_date = datetime.datetime.now().date() # 以当天为最后一天index_name = index_info.display_name # 指数全称df_pe_pb = get_pe_pb(index, start_date, end_date)df_pe_pb.head(10) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } pb pe date 2005-04-08 1.95560 20.30690 2005-04-11 1.95630 20.27660 2005-04-12 1.89530 19.94685 2005-04-13 1.95555 20.39210 2005-04-14 1.93260 19.93285 2005-04-15 1.89060 19.65655 2005-04-18 1.88145 19.49545 2005-04-19 1.89960 19.96190 2005-04-20 1.83585 19.86055 2005-04-21 1.80415 19.57075 12# 展示指数百分位趋势图df_quantile = get_quantile(index, 'pe', 7.45, df_pe_pb) 12# 展示指数百分位趋势图show_quantile(index, 'pe', 7.45, df_pe_pb) 123456789101112131415161718# 获取每个月的第一个交易日first_day = []for i in range(len(df_quantile)): date = df_quantile.index[i] if i == 0: first_day.append(date) else: last_date = df_quantile.index[i - 1] if date.day &lt; last_date.day: first_day.append(date)# 按月计算价格与涨跌幅度close = get_price(index, start_date=df_quantile.index[0], end_date=df_quantile.index[-1])['close']df = df_quantile.copy()df['close'] = closedf = df.loc[first_day]df['pct_change'] = df.close.pct_change()df.head(10) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } pb pe close quantile pct_change 2012-09-21 1.93745 17.02400 2199.06 0.106769 NaN 2012-10-08 1.98520 17.63935 2270.05 0.135113 0.032282 2012-11-01 1.93975 18.08920 2297.88 0.177766 0.012260 2012-12-03 1.66340 15.75390 2108.85 0.040726 -0.082263 2013-01-04 2.10385 18.96275 2524.41 0.261970 0.197055 2013-02-01 2.22630 20.12825 2743.32 0.329114 0.086717 2013-03-01 2.20090 20.36475 2668.84 0.344524 -0.027150 2013-04-01 1.98140 18.83550 2493.19 0.238305 -0.065815 2013-05-02 1.87415 17.33815 2449.64 0.114474 -0.017468 2013-06-03 2.00610 18.97265 2602.62 0.238855 0.062450 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748save_money = [] # 每月定存back_money = [] # 回收资金hold_money = [] # 持仓资金base_money = 1000 # 定投基准def trade(): for i in range(len(df)): quantile = df['quantile'][i] # 估值位 multiple = int((0.5 - quantile) * 10) # 定投倍数计算 if i == 0: # 初始买入 # 1.计算买入金额 _save_money = base_money * multiple save_money.append(_save_money) # 2. 计算回收金额 _back_money = 0 back_money.append(_back_money) # 3. 计算持仓变化 _hold_money = _save_money hold_money.append(_hold_money) continue if multiple &gt;=0: # 执行买入计算 # 1.计算买入金额 _save_money = base_money * multiple save_money.append(_save_money) # 2. 计算回收金额 _back_money = 0 back_money.append(_back_money) # 3. 计算持仓变化 _hold_money = hold_money[-1] * (1 + df['pct_change'][i]) + _save_money hold_money.append(_hold_money) else: # 执行卖出计算 # 1. 计算买入金额 _save_money = 0 save_money.append(_save_money) # 2. 计算回收金额 _back_money = base_money * (2 ** -multiple) # 按2的指数倍卖出 _hold_money = hold_money[-1] * (1 + df['pct_change'][i]) if _back_money &gt; _hold_money: _back_money = _hold_money if quantile &gt;= 1.0: _back_money = _hold_money # 如果达到100%分位，清仓 back_money.append(_back_money) # 3. 计算持仓变化 _hold_money = _hold_money - _back_money hold_money.append(_hold_money)trade() 12345678910111213141516df['save_money'] = save_money # 定投金额df['save_money_cumsum'] = df['save_money'].cumsum() # 定投累计金额df['hold_money'] = hold_money # 持仓金额df['back_money'] = back_money # 回收金额df['back_money_cumsum'] = df['back_money'].cumsum() # 累计回收金额df['total_money'] = df['hold_money'] + df['back_money_cumsum'] # 总资金df['return_money'] = df['total_money'] - df['save_money_cumsum'] # 持续收益df['return_rate'] = (df['total_money'] / df['save_money_cumsum']) - 1 # 持续收益率df[['save_money_cumsum', 'total_money', 'back_money_cumsum', 'return_money']].plot(figsize=(14, 7))plt.legend(['累积定投', '累计本息', '回收资金', '收益曲线'])plt.show()print('累计投入: &#123;&#125;元'.format(df['save_money_cumsum'][-1]))print('累计收益: &#123;&#125;元'.format(df['return_money'][-1]))print('最终本息累积: &#123;&#125;元'.format(df['total_money'][-1]))print('绝对收益率为: &#123;&#125;%'.format((df['return_money'][-1] / df['save_money_cumsum'][-1]) * 100)) 累计投入: 89000元 累计收益: 49339.34427308533元 最终本息累积: 138339.34427308533元 绝对收益率为: 55.43746547537677%12345678910111213141516171819# 展示各年投入金额money_year = &#123;&#125;for date in df.index: year = date.year if year in money_year.keys(): money_year[year] = money_year[year] + df.loc[date, 'save_money'] else: money_year[year] = df.loc[date, 'save_money'] money_mean = mean(list(money_year.values()))years_count = len(money_year) - 1money_year = &#123;key: [value] for key, value in money_year.items()&#125;df_money_year = pd.DataFrame(money_year, index=[''])df_money_year = df_money_year.Tdf_money_year.plot(figsize=(14, 4), kind='bar')plt.hlines(money_mean, 0, years_count, color='orange')plt.legend(['年均投入', '定投年金'])plt.show() 123456789101112# 展示各年的收益return_year = &#123;&#125;for date in df.index: year = date.year return_year[year] = df.loc[date, 'return_rate']return_year = &#123;key: [value] for key, value in return_year.items()&#125;return_df = pd.DataFrame(return_year, index=['return']).Treturn_df['diff'] = return_df['return'].diff()return_df['diff'].fillna(return_df['return'], inplace=True)return_df[['diff']].plot(figsize=(14, 4), kind='bar')plt.legend(['各年收益率'])plt.show() 通过以上的模型，我们可以观察到，一个牛熊的时间，投入的资产可以约摸翻一倍。根据72法则（72 / 年化利率 = 资产翻倍时间），得出 72 / 7.5年 = 9.6%,即，我们可以期望通过定投实现年化9.6%的年化复利效果。 作为朝九晚五甚至是996的工薪族来说，这无疑是一个振奋人心的消息。由于没有足够的时间关心投资市场的情况，也没有足够的知识去创建高频的交易模型，通过量化定投，可以每月看一次市场估值，根据百分位而选择适当的金额投入，一来强制自己每月储蓄，二来在时间横向发展过程中，渐渐的壮大资金，7.5年对工薪族来说，是一个恰当而合适的机会！ 定投并不是没有风险的，在投资过程中，就像上图一样，有某些年份是要亏损的，但只要做到耐心等待，合理分投，不盲目跟风，一定会迎一份属于你的惊喜！ 致天下所有奋斗者！","categories":[{"name":"python","slug":"python","permalink":"www.hicoder.com.cn/categories/python/"},{"name":"量化","slug":"python/量化","permalink":"www.hicoder.com.cn/categories/python/%E9%87%8F%E5%8C%96/"}],"tags":[{"name":"量化","slug":"量化","permalink":"www.hicoder.com.cn/tags/%E9%87%8F%E5%8C%96/"},{"name":"python","slug":"python","permalink":"www.hicoder.com.cn/tags/python/"}]},{"title":"KDJ指标在指数上的择时效应","slug":"KDJ指标在指数上的择时效应","date":"2020-05-04T01:51:31.000Z","updated":"2020-05-05T13:33:08.897Z","comments":true,"path":"2020/05/04/KDJ指标在指数上的择时效应/","link":"","permalink":"www.hicoder.com.cn/2020/05/04/KDJ%E6%8C%87%E6%A0%87%E5%9C%A8%E6%8C%87%E6%95%B0%E4%B8%8A%E7%9A%84%E6%8B%A9%E6%97%B6%E6%95%88%E5%BA%94/","excerpt":"基于聚宽研究环境，使用 environment 模块做回测分析。","text":"基于聚宽研究环境，使用 environment 模块做回测分析。 123456\"\"\"导入常用模块\"\"\"import numpy as npimport pandas as pdimport matplotlib.pyplot as pltimport datetimefrom environment import * # 导入回测模块 KDJ指标计算函数1234567891011121314151617181920212223242526272829303132333435import talib as tlfrom functools import reduce# SMA计算函数def SMA(close, timeperiod) : close = np.nan_to_num(close) return reduce(lambda x, y: ((timeperiod - 1) * x + y) / timeperiod, close) # KDJ计算函数def KDJ(high, low, close, fastk_period, slowk_period, fastd_period) : kValue, dValue = tl.STOCHF(high, low, close, fastk_period, fastd_period=1, fastd_matype=0) kValue = np.array(list(map(lambda x : SMA(kValue[:x], slowk_period), range(1, len(kValue) + 1)))) dValue = np.array(list(map(lambda x : SMA(kValue[:x], fastd_period), range(1, len(kValue) + 1)))) jValue = 3 * kValue - 2 * dValue func = lambda arr : np.array([0 if x &lt; 0 else (100 if x &gt; 100 else x) for x in arr]) kValue = func(kValue) dValue = func(dValue) jValue = func(jValue) return kValue, dValue, jValue# 获取某标的的KDJ信息def get_kdj(stock, count, end_date, unit): data = get_bars(security=stock, count=count, unit=unit, include_now=False, end_dt=end_date, fq_ref_date=None) close = data['close'] open = data['open'] high = data['high'] low = data['low'] return KDJ(high, low, close, 9, 3, 3) KDJ的使用方法可以参考：https://www.joinquant.com/view/community/detail/16464 KDJ指标使用方法 一KDJ是一种摆动指标，20与80的位置是我们对当前超买超卖状态的最基本判断。接下来的择时条件如下： 当D线处于20位置以下时，买进； 当D线处于80位置以上时，卖出； 另外，20与80的位置并不是硬性指标，我们可以为其指定一个浮动范围；我们将这个范围N值定在1%~9%之间，然后做回测，并查看其结果。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152trade_list = []N =[n/100 for n in range(1, 10)]for n in N: \"\"\"初始化以下内容\"\"\" context = Context() # 账户对象 order = Order(context) # 下单对象 trade = Trade(context, order) # 回测对旬 context.start_date = '2005-05-01' context.end_date = '2019-02-22' context.universe = ['000300.XSHG'] context.base = '000300.XSHG' \"\"\"策略主体\"\"\" def handle(context, order): stock = context.universe[0] current_date = trade.context.current_dt kdj_day = get_kdj(stock, 30, current_date, '1d') line_bottm = 20 * (1+n) line_top = 80 * (1-n) k1 = kdj_day[0][-1] d1 = kdj_day[1][-1] j1 = kdj_day[2][-1] k2 = kdj_day[0][-2] d2 = kdj_day[1][-2] j2 = kdj_day[2][-2] close = get_price(security=stock, end_date=context.current_dt, frequency='daily', fields=None, skip_paused=False, fq='pre', count=5)['close'] if d2 &gt; line_bottm and d1 &lt; line_bottm : if stock in context.position.keys(): return order.buy(stock, close[-1], context.cash // close[-1]) elif d2 &lt; line_top and d1 &gt; line_top: if stock not in context.position.keys(): return order.sell(stock, close[-1], context.position[stock]['count']) \"\"\"执行策略\"\"\" trade.trade(handle, show=False, log=True) trade_list.append(trade)# 展示Trade.show_ratio_compare('n', N, trade_list, 3, 3) End Time : 2019-03-10 16:01:27.192853, Elapsed Time: 0:00:18.351210 End Time : 2019-03-10 16:01:45.031913, Elapsed Time: 0:00:17.838861 End Time : 2019-03-10 16:02:02.843599, Elapsed Time: 0:00:17.811513 End Time : 2019-03-10 16:02:20.318987, Elapsed Time: 0:00:17.475214 End Time : 2019-03-10 16:02:38.392089, Elapsed Time: 0:00:18.072942 End Time : 2019-03-10 16:02:55.567773, Elapsed Time: 0:00:17.175470 End Time : 2019-03-10 16:03:13.802732, Elapsed Time: 0:00:18.234765 End Time : 2019-03-10 16:03:32.918843, Elapsed Time: 0:00:19.115479 End Time : 2019-03-10 16:03:51.401436, Elapsed Time: 0:00:18.482391 1Trade.show_result('n', N, trade_list) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } alpha beta 交易次数 回测时间 基准收益 夏普比率 年化收益 最大回撤 盈亏比 策略收益 胜率 n 0.01 -0.088320 0.3854 24 2005-05-01~2019-02-22 2.7662 -4.0289 -0.0237 0.5978 0.6680 -0.2740 0.5417 0.07 -0.092384 0.3463 27 2005-05-01~2019-02-22 2.7662 -4.1066 -0.0303 0.6063 0.5964 -0.3364 0.5185 0.08 -0.100810 0.3648 29 2005-05-01~2019-02-22 2.7662 -4.1761 -0.0375 0.6415 0.5394 -0.3995 0.5172 0.04 -0.100655 0.3468 24 2005-05-01~2019-02-22 2.7662 -4.4318 -0.0385 0.5986 0.4970 -0.4077 0.5417 0.05 -0.102086 0.3445 25 2005-05-01~2019-02-22 2.7662 -4.3913 -0.0401 0.5986 0.4827 -0.4205 0.5200 0.02 -0.106029 0.3877 24 2005-05-01~2019-02-22 2.7662 -4.7414 -0.0413 0.5925 0.4860 -0.4300 0.5000 0.06 -0.106598 0.3604 27 2005-05-01~2019-02-22 2.7662 -4.3707 -0.0436 0.6219 0.4449 -0.4480 0.4444 0.09 -0.108414 0.3642 29 2005-05-01~2019-02-22 2.7662 -4.3274 -0.0452 0.6370 0.4550 -0.4600 0.5172 0.03 -0.114031 0.3821 24 2005-05-01~2019-02-22 2.7662 -4.9898 -0.0497 0.6090 0.4252 -0.4928 0.5000 从上图来看，kdj在超买与超卖区的反应对于沪深300指数来说，反应并不好。 KDJ使用方法 二 当k线与d线形成金叉时买进； 当k线与d线形成死叉时卖出； 金叉与死叉形成时，最小的时间段是前天与当天的值的比较，这个时间段也可以被当作一种参数D，其取值范围是1~9天。查看回测结果： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849trade_list = []D = range(1, 10)for d in D: \"\"\"初始化以下内容\"\"\" context = Context() # 账户对象 order = Order(context) # 下单对象 trade = Trade(context, order) # 回测对旬 context.start_date = '2005-05-01' context.end_date = '2019-02-22' context.universe = ['000300.XSHG'] context.base = '000300.XSHG' \"\"\"策略主体\"\"\" def handle(context, order): stock = context.universe[0] current_date = trade.context.current_dt kdj_day = get_kdj(stock, 30, current_date, '1d') k1 = kdj_day[0][-1] d1 = kdj_day[1][-1] j1 = kdj_day[2][-1] k2 = kdj_day[0][-d-1] d2 = kdj_day[1][-d-1] j2 = kdj_day[2][-d-1] close = get_price(security=stock, end_date=context.current_dt, frequency='daily', fields=None, skip_paused=False, fq='pre', count=5)['close'] if k2 &lt; d2 and k1 &gt; d1: if stock in context.position.keys(): return order.buy(stock, close[-1], context.cash // close[-1]) elif k2 &gt; d2 and k1 &lt; d1: if stock not in context.position.keys(): return order.sell(stock, close[-1], context.position[stock]['count']) \"\"\"执行策略\"\"\" trade.trade(handle, show=False, log=True) trade_list.append(trade)# 展示Trade.show_ratio_compare('d', D, trade_list, 3, 3) End Time : 2019-03-10 16:04:13.577469, Elapsed Time: 0:00:20.034098 End Time : 2019-03-10 16:04:33.005696, Elapsed Time: 0:00:19.428044 End Time : 2019-03-10 16:04:52.154929, Elapsed Time: 0:00:19.149037 End Time : 2019-03-10 16:05:12.142793, Elapsed Time: 0:00:19.987659 End Time : 2019-03-10 16:05:31.073016, Elapsed Time: 0:00:18.930031 End Time : 2019-03-10 16:05:51.557113, Elapsed Time: 0:00:20.483901 End Time : 2019-03-10 16:06:10.902478, Elapsed Time: 0:00:19.345159 End Time : 2019-03-10 16:06:29.924519, Elapsed Time: 0:00:19.021839 End Time : 2019-03-10 16:06:48.871547, Elapsed Time: 0:00:18.946834 1Trade.show_result('d', D, trade_list) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } alpha beta 交易次数 回测时间 基准收益 夏普比率 年化收益 最大回撤 盈亏比 策略收益 胜率 d 2 0.009414 0.4432 290 2005-05-01~2019-02-22 2.7662 1.6912 0.0777 0.4224 1.1965 1.7096 0.4655 3 0.008740 0.4325 260 2005-05-01~2019-02-22 2.7662 1.6995 0.0763 0.4995 1.2031 1.6645 0.4846 1 -0.015884 0.4357 311 2005-05-01~2019-02-22 2.7662 1.4410 0.0519 0.4396 1.1350 0.9625 0.4759 8 -0.016955 0.4320 191 2005-05-01~2019-02-22 2.7662 1.7708 0.0506 0.6069 1.2340 0.9302 0.5340 4 -0.024804 0.4273 240 2005-05-01~2019-02-22 2.7662 0.9874 0.0424 0.4962 1.1123 0.7400 0.4708 5 -0.035541 0.4236 226 2005-05-01~2019-02-22 2.7662 0.6092 0.0315 0.5534 1.0970 0.5111 0.4779 6 -0.039586 0.4376 209 2005-05-01~2019-02-22 2.7662 0.5555 0.0283 0.5664 1.0921 0.4508 0.4976 7 -0.042921 0.4295 199 2005-05-01~2019-02-22 2.7662 0.3532 0.0245 0.5844 1.0933 0.3800 0.5075 9 -0.046487 0.4211 181 2005-05-01~2019-02-22 2.7662 0.0361 0.0204 0.5937 1.0899 0.3082 0.4972 从上面结果来看，当d=2时回测的效果比较好，但整体看来，仍旧没有跑赢大盘。因此，效果也并不理想。 KDJ使用方法 三 当j线与价格发生底背离时，买进； 当j线与价格发生顶背离时，卖出； 背离计算的是一段时间内，j线的趋势与价格的趋势在方向上不一致，把时间段设为D值，取值范围是1~9天。回测并查看结果： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849trade_list = []D = range(1, 10)for d in D: \"\"\"初始化以下内容\"\"\" context = Context() # 账户对象 order = Order(context) # 下单对象 trade = Trade(context, order) # 回测对旬 context.start_date = '2005-05-01' context.end_date = '2019-02-22' context.universe = ['000300.XSHG'] context.base = '000300.XSHG' \"\"\"策略主体\"\"\" def handle(context, order): stock = context.universe[0] current_date = trade.context.current_dt kdj_day = get_kdj(stock, 30, current_date, '1d') k1 = kdj_day[0][-1] d1 = kdj_day[1][-1] j1 = kdj_day[2][-1] k2 = kdj_day[0][-d-1] d2 = kdj_day[1][-d-1] j2 = kdj_day[2][-d-1] close = get_price(security=stock, end_date=context.current_dt, frequency='daily', fields=None, skip_paused=False, fq='pre', count=20)['close'] if j1 &gt; j2 and close[-1] &lt; close[-d-1]: if stock in context.position.keys(): return order.buy(stock, close[-1], context.cash // close[-1]) elif j1 &lt; j2 and close[-1] &gt; close[-d-1]: if stock not in context.position.keys(): return order.sell(stock, close[-1], context.position[stock]['count']) \"\"\"执行策略\"\"\" trade.trade(handle, show=False, log=True) trade_list.append(trade)# 展示Trade.show_ratio_compare('d', D, trade_list, 3, 3) End Time : 2019-03-10 16:07:10.097162, Elapsed Time: 0:00:19.401507 End Time : 2019-03-10 16:07:30.041172, Elapsed Time: 0:00:19.943802 End Time : 2019-03-10 16:07:51.642053, Elapsed Time: 0:00:21.600708 End Time : 2019-03-10 16:08:12.491229, Elapsed Time: 0:00:20.848990 End Time : 2019-03-10 16:08:32.879961, Elapsed Time: 0:00:20.388533 End Time : 2019-03-10 16:08:53.409177, Elapsed Time: 0:00:20.528626 End Time : 2019-03-10 16:09:12.488550, Elapsed Time: 0:00:19.079192 End Time : 2019-03-10 16:09:32.450308, Elapsed Time: 0:00:19.961573 End Time : 2019-03-10 16:09:52.517584, Elapsed Time: 0:00:20.067092 1Trade.show_result('d', D, trade_list) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } alpha beta 交易次数 回测时间 基准收益 夏普比率 年化收益 最大回撤 盈亏比 策略收益 胜率 d 1 -0.077736 0.4270 451 2005-05-01~2019-02-22 2.7662 -2.0861 -0.0105 0.6100 0.9727 -0.1313 0.6341 6 -0.110904 0.4822 109 2005-05-01~2019-02-22 2.7662 -4.2251 -0.0402 0.6891 0.7025 -0.4208 0.5688 3 -0.117829 0.5435 199 2005-05-01~2019-02-22 2.7662 -5.1090 -0.0432 0.6616 0.7790 -0.4446 0.6281 9 -0.113946 0.4604 81 2005-05-01~2019-02-22 2.7662 -4.6125 -0.0446 0.6432 0.6487 -0.4555 0.5802 7 -0.116218 0.4692 93 2005-05-01~2019-02-22 2.7662 -4.5738 -0.0463 0.7141 0.6920 -0.4683 0.6237 8 -0.126615 0.4572 79 2005-05-01~2019-02-22 2.7662 -5.4340 -0.0575 0.6776 0.5574 -0.5455 0.5696 2 -0.139678 0.4686 279 2005-05-01~2019-02-22 2.7662 -6.1486 -0.0698 0.7485 0.7312 -0.6187 0.5950 5 -0.157658 0.5356 121 2005-05-01~2019-02-22 2.7662 -6.7588 -0.0835 0.7425 0.5475 -0.6871 0.5785 4 -0.191193 0.4823 140 2005-05-01~2019-02-22 2.7662 -8.0771 -0.1204 0.8319 0.4296 -0.8192 0.5500 从上图来看，j线的背离效果也不好，k线与d线的背离效果这里就不做加测了。 下面展示本次研究效果最好的参数，即金叉与死叉条件下，d=2时的结果。123456789101112131415161718192021222324252627282930313233343536373839404142\"\"\"初始化以下内容\"\"\"context = Context() # 账户对象order = Order(context) # 下单对象trade = Trade(context, order) # 回测对旬context.start_date = '2005-05-01'context.end_date = '2019-02-22'context.universe = ['000300.XSHG']context.base = '000300.XSHG'\"\"\"策略主体\"\"\"def handle(context, order): stock = context.universe[0] current_date = trade.context.current_dt kdj_day = get_kdj(stock, 30, current_date, '1d') k1 = kdj_day[0][-1] d1 = kdj_day[1][-1] j1 = kdj_day[2][-1] k2 = kdj_day[0][-2-1] d2 = kdj_day[1][-2-1] j2 = kdj_day[2][-2-1] close = get_price(security=stock, end_date=context.current_dt, frequency='daily', fields=None, skip_paused=False, fq='pre', count=20)['close'] if k2 &lt; d2 and k1 &gt; d1: if stock in context.position.keys(): return order.buy(stock, close[-1], context.cash // close[-1]) elif k2 &gt; d2 and k1 &lt; d1: if stock not in context.position.keys(): return order.sell(stock, close[-1], context.position[stock]['count'])\"\"\"执行策略\"\"\"trade.trade(handle, show=True, log=True) End Time : 2019-03-10 16:11:04.901546, Elapsed Time: 0:00:20.362267","categories":[{"name":"python","slug":"python","permalink":"www.hicoder.com.cn/categories/python/"},{"name":"量化","slug":"python/量化","permalink":"www.hicoder.com.cn/categories/python/%E9%87%8F%E5%8C%96/"}],"tags":[{"name":"量化","slug":"量化","permalink":"www.hicoder.com.cn/tags/%E9%87%8F%E5%8C%96/"},{"name":"python","slug":"python","permalink":"www.hicoder.com.cn/tags/python/"}]},{"title":"聚宽回测分析模块","slug":"聚宽回测分析模块","date":"2020-05-04T01:33:36.000Z","updated":"2020-05-05T13:31:12.779Z","comments":true,"path":"2020/05/04/聚宽回测分析模块/","link":"","permalink":"www.hicoder.com.cn/2020/05/04/%E8%81%9A%E5%AE%BD%E5%9B%9E%E6%B5%8B%E5%88%86%E6%9E%90%E6%A8%A1%E5%9D%97/","excerpt":"下面的代码是一个简单的回测模块，数据需要引用聚宽的 jqdata。把下面的代码保存为一个.py 文件，然后上传到聚宽研究根目录下（或者你研究所在文件目录下），然后使用from 文件名 import *，即可导入该模块。","text":"下面的代码是一个简单的回测模块，数据需要引用聚宽的 jqdata。把下面的代码保存为一个.py 文件，然后上传到聚宽研究根目录下（或者你研究所在文件目录下），然后使用from 文件名 import *，即可导入该模块。 具体方法请参考：KDJ指标在指数上的择时效应 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390\"\"\"导入常用模块\"\"\"import numpy as npimport pandas as pdimport matplotlib.pyplot as pltimport datetimefrom jqdata import *from pylab import mplimport seaborn as snsmpl.rcParams['font.sans-serif'] = ['FangSong'] # 指定默认字体mpl.rcParams['axes.unicode_minus'] = False # 解决保存图像是负号'-'显示为方块的问题\"\"\"账户类\"\"\"class Context: def __init__(self): self.cash = self.Cash = 100000 # 默认初始资金 self.base = '000300.XSHG' # 默认参考基准 self.position = &#123;&#125; # 持仓 self.universe = [] # 标的池 self.current_dt = '2016-01-01' self.start_date = '2016-01-01' # 默认交易开始时间 self.end_date = '2016-12-31' # 默认交易结束时间 self.total_value = 0 # 总价值 self.trade_history = [] # 交易历史记录 self.day_value = [] # 日收益记录 self.trade_days = 0 # 记录每日收益 def write_ratio(self, security, date): the_value = self.cash for s in self.position.keys(): # 计算相对于上个交易日的涨跌幅度 price = get_price(s, end_date=date, frequency='daily', fields=['close'], skip_paused=False, fq='pre', count=10)['close'] value = self.position[s]['count']*price[-1] the_value += value self.day_value.append(&#123;'date':date, 'value':the_value&#125;) \"\"\"下单类\"\"\"class Order: context = Context() def __init__(self, context): self.context = context # 交易函数，买入与卖出 def buy(self, security, price, count): if price * count &gt; self.context.cash: print('资金不足，请调整数量！') return if security in self.context.position.keys(): print('暂不支持重复下单！') return _total_value = price * count self.context.cash -= _total_value _positon = &#123;'security': security, 'price': price, 'count': count, 'date': self.context.current_dt, 'type': 'buy', 'hold_value': price * count, 'available_cash': self.context.cash&#125; self.context.trade_history.append(_positon) self.context.total_value = self.context.cash + _total_value self.context.position[security] = _positon def sell(self, security, price, count): if security not in self.context.position.keys(): print('持仓中不包含标的&#123;&#125;，无法交易！'.format(security)) return if count != self.context.position[security]['count']: print('这支持分批卖出，请输入全部数量！') return _total_value = price * count self.context.cash += _total_value _positon = &#123;'security': security, 'price': price, 'count': count, 'date': self.context.current_dt, 'type': 'sell', 'hold_value': price * count, 'available_cash': self.context.cash&#125; self.context.trade_history.append(_positon) self.context.total_value = self.context.cash # ? del self.context.position[security]\"\"\"交易类\"\"\"class Trade: def __init__(self, context, order): self.context = context # 账户 self.order = order # 下单对象 self.result = &#123;&#125; # 回测后的评估指标 self.price = None # 价格缓存 self.maxdown_point = [] # 记录最大回撤点位 # 策略回测 def trade(self, func, show=True, log=False): time_start = datetime.datetime.now() self.price = get_price(security=self.context.base, start_date=self.context.start_date, end_date=self.context.end_date, frequency='daily', fields=None, skip_paused=False, fq='pre') close = self.price['close'] for i in range(0, len(close)): self.context.current_dt = close.index[i] self.context.trade_days = i+1 func(self.context, self.order) self.context.write_ratio(self.context.universe[0], self.context.current_dt) self.get_result() time_end = datetime.datetime.now() if log: print('End Time : &#123;0&#125;, Elapsed Time: &#123;1&#125;'.format(datetime.datetime.now(), time_end - time_start)) if show: self.show_ratio() # 查询交易记录详情 def get_trade_detail(self): _df = pd.DataFrame(self.context.trade_history, columns=['date', 'security', 'type', 'price', 'count', 'hold_value', 'available_cash']) _df.rename(columns=&#123;'date': '时间', 'security': '标的', 'type': '交易类型', 'price': '交易价格', 'count': '交易数量', 'hold_value': '持仓价值', 'available_cash': '可用资金'&#125;, inplace=True) return _df \"\"\"评估指标\"\"\" # 策略收益 def get_absolute_return(self): _cash = pd.DataFrame(self.context.day_value)['value'].iloc[-1] return (_cash - self.context.Cash) / self.context.Cash \"\"\" 年化收益率公式为： 年化收收益率 = （总收益 + 1）** (365.25/天数) -1 【计算自然日/年化收益率】 年化收收益率 = （总收益 + 1）** (250/天数) -1 【计算交易日/年化收益率】 \"\"\" # 策略年化收益率 def get_annualized_return(self): _cash = pd.DataFrame(self.context.day_value)['value'].iloc[-1] ratio = (_cash - self.context.Cash) / self.context.Cash return_value = (1 + ratio) ** (252 / len(self.context.day_value)) - 1 return return_value # 基准收益 def get_benchmark_return(self): ben_data = self.price benchmark_return = (ben_data['close'][-1] - ben_data['open'][0]) / ben_data['open'][0] return benchmark_return # 基准年化收益率 def get_anbenchmark_return(self): anbenchmark_return = (1 + self.get_benchmark_return()) ** (250 / len(self.context.day_value)) - 1 return anbenchmark_return # 计算盈亏比 def get_profit_loss_than(self): _df = pd.DataFrame(self.context.trade_history) if _df.shape[0] &lt;= 0: return 0 _df['total_value'] = _df['available_cash'] + _df['hold_value'] _sell = _df[_df['type'] == 'sell']['available_cash'] _trade_count = _df[_df['type'] == 'sell'].shape[0] _buy = _df[_df['type'] == 'buy']['total_value'][0:_trade_count] ratio = np.array(_sell) - np.array(_buy) return abs(ratio[ratio &gt; 0].sum()/ratio[ratio &lt; 0].sum()) # 计算交易次数 def get_trade_count(self): _df = pd.DataFrame(self.context.trade_history) if _df.shape[0] &lt;= 0: return 0 return len(_df[_df['type'] == 'sell'].index) # 计算胜率 def get_wine_rate(self): _df = pd.DataFrame(self.context.trade_history) if _df.shape[0] &lt;= 0: return 0 _df['total_value'] = _df['available_cash'] + _df['hold_value'] _sell = _df[_df['type'] == 'sell']['available_cash'] _trade_count = _df[_df['type'] == 'sell'].shape[0] _buy = _df[_df['type'] == 'buy']['total_value'][0:_trade_count] ratio = np.array(_sell) - np.array(_buy) return len(ratio[ratio &gt; 0])/len(ratio) # 夏普比率 def get_sharpe(self): _df = pd.DataFrame(self.context.day_value) if _df.shape[0] &lt;= 0: return 0 std = ((_df['value'] - self.context.Cash) / self.context.Cash).std() if std == 0: return 0 return (self.get_annualized_return() - 0.02) * np.sqrt(252) / std # beta def get_beta(self): ben_data = self.price ben_data['income'] = ben_data['close'].shift(1) ben_data['income1'] = ben_data['close'].astype(float) - ben_data['income'].astype(float) ben_data['income2'] = ben_data['income1'] / ben_data['income'] ben_data_income = np.array(list(ben_data['income2'].dropna())) # 策略每日收益 _df = pd.DataFrame(self.context.day_value) _df['income'] = _df['value'].shift(1) _df['income1'] = _df['value'].astype(float) - _df['income'].astype(float) _df['income2'] = _df['income1'] / _df['income'] _df_income = np.array(list(_df['income2'].dropna())) x = np.cov(ben_data_income, _df_income) y = np.var(ben_data_income) # 获取beta值 x_y_data = round(x[0][1]/y, 4) return x_y_data # alpha def get_alpha(self): alpha_data = self.get_annualized_return() - (0.04 + self.get_beta() * (self.get_anbenchmark_return() - 0.04)) return alpha_data \"\"\" 最大回撤计算方式： 在选定周期内任一历史点往后推，净值下降到最低点时的收益率回撤幅度的最大值。 计算方式有两种： 1. 往前计算，首先计算出每天和前面最高点比的最大回撤：1 - 当天值 / 前面的最大值，然后计算出这些数据里最大的值。 2. 往二计算，首先计算出每天和后面最低点比较的最大回撤：1 - 后面的最小值 / 当天值，然后计算出这些数据里最大值。 \"\"\" # 最大回撤 def get_maxdown(self): _df = pd.DataFrame(self.context.day_value) return_list = _df['value'] i = np.argmax((np.maximum.accumulate(return_list) - return_list) / np.maximum.accumulate(return_list)) # 结束位置 if i == 0: return 0 j = np.argmax(return_list[:i]) # 开始位置 # 记录最大回撤的点位 self.maxdown_point.append(_df.iloc[j]) self.maxdown_point.append(_df.iloc[i]) return (return_list[j] - return_list[i]) / (return_list[j]) # 总结回测信息 def get_result(self): _dic = &#123;'基准收益':round(self.get_benchmark_return(), 4), '策略收益':round(self.get_absolute_return(), 4), '年化收益':round(self.get_annualized_return(), 4), '最大回撤':round(self.get_maxdown(), 4), '夏普比率':round(self.get_sharpe(), 4), '盈亏比':round(self.get_profit_loss_than(), 4), '胜率':round(self.get_wine_rate(), 4), '交易次数':self.get_trade_count(), 'beta':self.get_beta(), 'alpha':self.get_alpha(), '回测时间':self.context.start_date+'~'+self.context.end_date&#125; self.result = _dic return _dic # 报表展示 @staticmethod def show_result(index_name, index_list, trade_list): _list = [] for i in range(0, len(trade_list)): _trade = trade_list[i] _dic = _trade.result _dic[index_name] = index_list[i] _list.append(_trade.result) _df = pd.DataFrame(_list) _df = _df.set_index(index_name) _df = _df.sort_values(by=['年化收益','最大回撤', 'alpha', '夏普比率', 'beta', '胜率'], ascending=(False, True, False, False, True, False)) return _df \"\"\"图例展示，所有的评估皆以收盘价为基准\"\"\" # 展示收益率曲线 def show_ratio(self, w=20, h=7): sns.set() _price = self.price # 大盘相对涨幅 start_price = _price['close'].iloc[0] _price['dapan_ratio'] = (_price['close'] - start_price) / start_price # 策略的相对涨幅 _day_price = pd.DataFrame(self.context.day_value) _day_price['trade_ratio'] = (_day_price['value'] - self.context.Cash) / self.context.Cash plt.figure(figsize=(w, h)) # 收益曲线 plt.plot(_price.index, _price['dapan_ratio'], linewidth = '2', color='#FF4500') plt.plot(_day_price['date'], _day_price['trade_ratio'], linewidth = '2', color='#1E90FF') # 回撤点位 x_list = [date['date'] for date in self.maxdown_point] y_list = [(date['value'] - self.context.Cash) / self.context.Cash for date in self.maxdown_point] plt.scatter(x_list, y_list, c='g',linewidths=7, marker='o') # 评估指标 plt.title('Benchmark Returns &#123;0&#125;|Total Returns &#123;1&#125;|Annualized Returns &#123;2&#125;|Max Drawdown &#123;3&#125;|RunTime &#123;4&#125;'.format( self.result['基准收益'], self.result['策略收益'], self.result['年化收益'], self.result['最大回撤'], self.result['回测时间']), fontsize=16) plt.grid(True) plt.legend(['Benchmark Returns', 'Total Returns'], loc=2, fontsize=14) plt.show() # 查看对比图 @staticmethod def show_ratio_compare(index_name, index_list, trade_list, r=2, c=2, w=16, h=9): \"\"\"指标名，指标列表，交易对象列表，绘图行数，绘图列数\"\"\" sns.set() # 计算一个子图的宽 width = w / c # 计算一个子图的高 high = width*0.56 figure,ax = plt.subplots(r, c, figsize=(w,(high+0.5)*r)) j = 0 for _ax in ax: for __ax in _ax: trade = trade_list[j] _price = trade.price # 大盘相对涨幅 start_price = _price['close'].iloc[0] _price['dapan_ratio'] = (_price['close'] - start_price) / start_price # 策略的相对涨幅 _day_price = pd.DataFrame(trade.context.day_value) _day_price['trade_ratio'] = (_day_price['value'] - trade.context.Cash) / trade.context.Cash __ax.plot(_price.index, _price['dapan_ratio'], color='#FF4500') __ax.plot(_day_price['date'], _day_price['trade_ratio'], color='#1E90FF') __ax.set_title('&#123;0&#125;=&#123;1&#125;'.format(index_name,index_list[j],), fontsize=14) j += 1 plt.show() @staticmethod def show_all_ratio(name , ma_list, trade_list, w=16, h=9): sns.set() _legend = [name+'='+str(_ma) for _ma in ma_list] plt.figure(figsize=(w, h)) for trade in trade_list: _day_price = pd.DataFrame(trade.context.day_value) _day_price['trade_ratio'] = (_day_price['value'] - trade.context.Cash) / trade.context.Cash plt.plot(_day_price['date'], _day_price['trade_ratio']) plt.legend(_legend) plt.show() class Picture: \"\"\"展示指标图\"\"\" passclass Model: \"\"\"交易模型，保存量化后的参数\"\"\" pass","categories":[{"name":"python","slug":"python","permalink":"www.hicoder.com.cn/categories/python/"},{"name":"量化","slug":"python/量化","permalink":"www.hicoder.com.cn/categories/python/%E9%87%8F%E5%8C%96/"}],"tags":[{"name":"量化","slug":"量化","permalink":"www.hicoder.com.cn/tags/%E9%87%8F%E5%8C%96/"},{"name":"python","slug":"python","permalink":"www.hicoder.com.cn/tags/python/"}]},{"title":"HiCoder上线啦","slug":"HiCoder上线啦","date":"2020-05-03T13:53:25.000Z","updated":"2020-05-04T04:44:16.547Z","comments":true,"path":"2020/05/03/HiCoder上线啦/","link":"","permalink":"www.hicoder.com.cn/2020/05/03/HiCoder%E4%B8%8A%E7%BA%BF%E5%95%A6/","excerpt":"","text":"HiCoder 终于和大家见面啦。 HiCoder 站点很早就搭建好了，但一直没想好要用它来做什么。也许这就是种缘份吧——你遇见一个人，起初不在意，可要分别了才发现难以割舍。我正是怀着这样一种心情，不断的往前摸索，忽然发现 HiCoder 可以为“程序猿”或“码家”们提供一个学习、吐槽和不断精进的基地。 时代在进步、科技在发展，趴在键盘上敲着代码的年轻人也越来越多，他们只身异地，披星\b戴月，陪着他们的可能仅有电脑和从来不打电话的手机。有多少人关心过程序员们的内心？有多少人曾关心过他们的身体？他们像也大多数人一样，渴望拥抱，渴望家的温暖，渴望被人倾听…… 也许我也不善言辞，但我想对那些努力的 Coder 们说一句：Hi!","categories":[{"name":"阅读","slug":"阅读","permalink":"www.hicoder.com.cn/categories/%E9%98%85%E8%AF%BB/"},{"name":"公告","slug":"阅读/公告","permalink":"www.hicoder.com.cn/categories/%E9%98%85%E8%AF%BB/%E5%85%AC%E5%91%8A/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"www.hicoder.com.cn/tags/%E9%9A%8F%E7%AC%94/"}]}],"categories":[{"name":"编程","slug":"编程","permalink":"www.hicoder.com.cn/categories/%E7%BC%96%E7%A8%8B/"},{"name":"hexo","slug":"编程/hexo","permalink":"www.hicoder.com.cn/categories/%E7%BC%96%E7%A8%8B/hexo/"},{"name":"敏捷","slug":"敏捷","permalink":"www.hicoder.com.cn/categories/%E6%95%8F%E6%8D%B7/"},{"name":"精益","slug":"敏捷/精益","permalink":"www.hicoder.com.cn/categories/%E6%95%8F%E6%8D%B7/%E7%B2%BE%E7%9B%8A/"},{"name":"python","slug":"python","permalink":"www.hicoder.com.cn/categories/python/"},{"name":"量化","slug":"python/量化","permalink":"www.hicoder.com.cn/categories/python/%E9%87%8F%E5%8C%96/"},{"name":"阅读","slug":"阅读","permalink":"www.hicoder.com.cn/categories/%E9%98%85%E8%AF%BB/"},{"name":"公告","slug":"阅读/公告","permalink":"www.hicoder.com.cn/categories/%E9%98%85%E8%AF%BB/%E5%85%AC%E5%91%8A/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"www.hicoder.com.cn/tags/hexo/"},{"name":"github","slug":"github","permalink":"www.hicoder.com.cn/tags/github/"},{"name":"网站","slug":"网站","permalink":"www.hicoder.com.cn/tags/%E7%BD%91%E7%AB%99/"},{"name":"博客","slug":"博客","permalink":"www.hicoder.com.cn/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"敏捷","slug":"敏捷","permalink":"www.hicoder.com.cn/tags/%E6%95%8F%E6%8D%B7/"},{"name":"精益","slug":"精益","permalink":"www.hicoder.com.cn/tags/%E7%B2%BE%E7%9B%8A/"},{"name":"MVP","slug":"MVP","permalink":"www.hicoder.com.cn/tags/MVP/"},{"name":"量化","slug":"量化","permalink":"www.hicoder.com.cn/tags/%E9%87%8F%E5%8C%96/"},{"name":"python","slug":"python","permalink":"www.hicoder.com.cn/tags/python/"},{"name":"随笔","slug":"随笔","permalink":"www.hicoder.com.cn/tags/%E9%9A%8F%E7%AC%94/"}]}