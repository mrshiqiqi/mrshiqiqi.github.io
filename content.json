{"meta":{"title":"HiCoder","subtitle":"","description":"","author":"shiqiqi","url":"www.hicoder.com.cn","root":"/"},"pages":[],"posts":[{"title":"量化定投，工薪族逆袭之路","slug":"量化定投，工薪族逆袭之路","date":"2020-05-04T02:12:31.000Z","updated":"2020-05-05T02:23:21.853Z","comments":true,"path":"2020/05/04/量化定投，工薪族逆袭之路/","link":"","permalink":"www.hicoder.com.cn/2020/05/04/%E9%87%8F%E5%8C%96%E5%AE%9A%E6%8A%95%EF%BC%8C%E5%B7%A5%E8%96%AA%E6%97%8F%E9%80%86%E8%A2%AD%E4%B9%8B%E8%B7%AF/","excerpt":"一个人一生能积累多少钱，不是取决于他能够赚多少钱，而是取决于他如何投资理财，人找钱不如钱找钱，要知道让钱为你工作，而不是你为钱工作。——（美）沃伦●巴菲特","text":"一个人一生能积累多少钱，不是取决于他能够赚多少钱，而是取决于他如何投资理财，人找钱不如钱找钱，要知道让钱为你工作，而不是你为钱工作。——（美）沃伦●巴菲特 1234567891011# 导入常用的库import numpy as npimport pandas as pd import datetime as dtimport timeimport matplotlib.pyplot as pltimport seaborn as snsfrom jqdata import *import tushare as tsimport seaborn as snsplt.style.use('fivethirtyeight') 一、指数格局，跌宕起伏这里的指数，我们重点说一下上证指数、深圳指数。指数其实是一篮子股票，它反应的这些股票总体的表现。而上证与深圳指数更反应出当下国内的经济形式（当然不是百分百的呈现）。 相信大家都了解过经济周期，理论上，社会环境的经济会以衰退－萧条－复苏－繁荣四种形式往复呈现。不过，由于不同国家的国情不尽相同，这种周而复始的周期曲线表现得并不完美。 下图为经济周期曲线图： 那么，股市是否也会呈现一定的周期性呢？如果具有周期性，如何估算牛熊之间的时间距离呢？带着这样的疑问，接着往下探究。 在探究此问题之前，可以去查找一下相关的历史资料，看看是否有人已经给出答案，或者可以找一些重要的线索。经过百度，收集到：上证指数1990年12月19号成立，之后的经历了4次牛市，分别1993年2月、2001年6月、2007年10月、2015年6月。让我们来实际看一下上证指数全部的趋势情况。 1234567891011121314151617181920212223242526plt.style.use('fivethirtyeight')# 由于数据量比较多，这里打算从 tushare 获取上证指数所有的价格数据# tushare 接口，参数为注册时生成的 tokenpro = ts.pro_api('xxxxxxxxx')# tushare 要求一次最多获取 3000 条数据，所以分两次获取# 然后将数据合并，按时间排序df1 = pro.index_daily(ts_code='000001.SH', start_date='19901219', end_date='20101231')df2 = pro.index_daily(ts_code='000001.SH', start_date='20110101', end_date='20190630')df = pd.concat([df2, df1]) # 合并df = df.sort_values(by=['trade_date']) # 排序df['trade_date'] = pd.to_datetime(df['trade_date']) # 转换为时间类型df.set_index(['trade_date'], inplace=True) # 设置索引列df.index.name = None # 去掉索引列名# 将上证指数价格曲线画出来# 并在对应的牛市年份，画一条竖线来标记df.close.plot(figsize=(14, 7), title='牛顶间隔展示')for year in ['1993-02-01', '2001-06-01', '2007-10-01', '2015-06-01']: plt.axvline(year,color='r', alpha=0.7)plt.show() 看完这张图，大概大家都会感慨：曾经的股市是多么的疯狂，它也像人生，起起伏伏。粗一看，感觉指数的起伏是有一定的周期性规律可寻的，但仔细看却发现，各牛市间的时间间隔并不匀称。那问题来了，各牛市顶点的时间间隔大概在什么样的取值范围呢？未来大盘的趋势是否会符合某种规律呢？接下来我们计算一下各牛顶时间节点的平均间隔时间与偏差。 1234567891011121314151617181920212223242526# 转换成时间格式best_years = [dt.datetime.strptime(year, '%Y-%m-%d').date() for year in ['1993-02-01', '2001-06-01', '2007-10-01', '2015-06-01']]# 计算牛顶时间间隔gap_year = [days.days for days in np.diff(best_years)]print('牛顶平均间隔时间：', ['&#123;&#125; days'.format(days) for days in gap_year])# 计算平均间隔年数，为避免盲目猜测，再计算出均值的偏差值mean_gap = np.mean(gap_year)print('平均时间间隔 &#123;&#125; 天，即 &#123;&#125; 年'.format(round(mean_gap, 2), round(mean_gap / 365, 2)))# 计算平均时间间隔偏差值std_gap = np.std(gap_year)print('平均时间间隔偏差 &#123;&#125; 天，即 &#123;&#125; 年'.format(round(std_gap, 2), round(std_gap / 365, 2)))# 计算下一个牛市出现的合理时间区间early_year = (best_years[-1] + dt.timedelta(round(mean_gap - std_gap, 0)))latest_year = (best_years[-1] + dt.timedelta(round(mean_gap + std_gap, 0)))# 构造 titleearly_y = early_year.yearearly_m = early_year.monthlatest_y = latest_year.yearlatest_m = latest_year.monthprint('下个牛顶时间范围 &#123;&#125;年&#123;&#125;月 ~ &#123;&#125;年&#123;&#125;月'.format(early_y, early_m, latest_y, latest_m)) 牛顶平均间隔时间： [&apos;3042 days&apos;, &apos;2313 days&apos;, &apos;2800 days&apos;] 平均时间间隔 2718.33 天，即 7.45 年 平均时间间隔偏差 303.16 天，即 0.83 年 下个牛顶时间范围 2022年1月 ~ 2023年9月123456789101112title = '评估下个牛顶时间范围 &#123;&#125;年&#123;&#125;月 ~ &#123;&#125;年&#123;&#125;月'.format(early_y, early_m, latest_y, latest_m)df.close.plot(figsize=(14, 7), title=title)for year in ['1993-02-01', '2001-06-01', '2007-10-01', '2015-06-01']: plt.axvline(year,color='r', alpha=0.6) # 生成 2019-02-11 ~ 2023-12-10 的时间区间# 如果要填充一个区间，y 就给价格的最大值便好date_span = pd.date_range(early_year, latest_year)value_span = [df.close.max() for x in date_span]plt.fill_between(date_span, value_span, color='orange', alpha=0.8)plt.show() 这里需要提醒一下大家：历史数据只可用来评估一些现象，但绝不能 100% 预言未来！所以大家还要带着辩证的心态看待这个结果。 通过上面的统计与可视化，可得出以下结论： 一轮牛熊的平均时间间隔为7.5年左右； 4轮牛熊的时间偏差在0.8年左右； 依此估算的下个牛顶的时间范围在2022年1月 ~ 2023年9月之间。 假设这个结果是大概率可信的，那在到达牛顶之前，一定要经过一个牛市的启动阶段——所以，低估值与熊之尾巴才是最宝贵的！！！ 二、定投畅想，看好国运指数的价格一直在波动起伏，但从宏观看来，其底部是一直在抬高的。只要国家经济一直是向好的，那指数的从超长期来看，是总体向上发展的。也就是说，买指数产品，就是看好国运！ 例如下图，通过线性回归，我们可以看出，上证指数的价格整体趋势是向上的。假如在上证指数成立之初我们就买入，并一直持有到现在，到目前为止的收益将是多少呢？我们来做个计算。 1234# 通过线性回归，刻画整体平均趋势plt.figure(figsize=(14, 7))sns.regplot(x=np.arange(0, df.shape[0]), y=df.close.values)plt.show() 1234567891011121314151617181920# 为了计算方便，默认都倩收盘价格为准# 获取上市第一天的收盘价和当前收盘价start_price = df.close[0]end_price = df.close[-1]print('最初收盘价为 &#123;&#125;，当前收盘价为 &#123;&#125;'.format(start_price, end_price))# 计算收益率total_return = (end_price / start_price) - 1print('持有到目前为止的收益率为 &#123;&#125;%'.format(round(total_return * 100, 2)))# 计算年平均收益，一年以250个交易日为准# 平均年化收益率=(投资内收益/本金)×（250/投资天数）× 100%mean_return = total_return * (250 / df.shape[0])print('平均每年收益率为 &#123;&#125;%'.format(round(mean_return * 100, 2)))# 计算年化收益率复利# 本息和 = 本金 * （年化利率 + 1）的 n 次方，n为交易年数# 年化利率 = （本息和 / 本金）的 n次开根 - 1annualized_return = pow((end_price / start_price), 1 / (df.shape[0] / 250)) - 1print('年化收益率为 &#123;&#125;%'.format(round(annualized_return * 100, 2))) 最初收盘价为 99.98，当前收盘价为 2978.8784 持有到目前为止的收益率为 2879.47% 平均每年收益率为 103.22% 年化收益率为 12.94%看到这里，可能小伙伴们都张大了嘴大喊：“这不可能！我不相信！”是的，12.9% 的年化复利，的确很夸张。但这并不是表明指数收益相当可观，这其中的原因是： 指数刚上市的时候净值很低； 中国的经济已经发生了天翻地覆的变化； 持有的时间相对长； 没有考虑通货膨胀与金钱的时间价值。 现在我们已经知道，指数从长期来看是持续向上发展的，而在指数投资中，越早投资获得的收益越好。但对于大部分的式蒺族来说，大家的理财理念并没有得到较好的普及，况且投资是一项需要承担较高风险的活动，许多工薪族朋友只能看着自己的钱包在非理性消费与通货膨胀的影响下不断的缩水。有些拥有比较好的习惯的工薪族会将部分收入储蓄到银行卡中，但仍旧逃不过金钱被贬值的命运！ 其实，工薪族如果了解“定投”这个概念的话，是可以将一部分的资金从银行卡里拿出来定期存到指数投资产品中的。如果去百度定投的概念，那么会出现一些关键字，比如“低估值”，“风险平摊”，“定期定额度”，“微笑曲线”等，如果对于定投不太了解，可以先去百度一下定投的理念。 接下来，我们构建一个以定期定额方式投资指数的模型，看看最终的投资效果如何。 模型描述： 最早日期选定在上证指数公布的那一天； 每月的第一个交易日买入上证指数1000元； 假设指数的净值已经缩小到个位数,即 1000 元可以正常交易； 持有到现在，没有卖出。 本模型不考虑交易费用与滑点，默认每次的投入本金都可以全部买进！ 12345678910111213# 获取每个月的第一个交易日的数据first_day = []for i in range(len(df)): date = df.index[i] if i == 0: first_day.append(date) else: last_date = df.index[i - 1] if date.day &lt; last_date.day: first_day.append(date) index_df = df.loc[first_day]index_df.index DatetimeIndex([&apos;1990-12-19&apos;, &apos;1991-01-02&apos;, &apos;1991-02-01&apos;, &apos;1991-03-01&apos;, &apos;1991-04-01&apos;, &apos;1991-05-02&apos;, &apos;1991-06-03&apos;, &apos;1991-07-01&apos;, &apos;1991-08-01&apos;, &apos;1991-09-02&apos;, ... &apos;2018-09-03&apos;, &apos;2018-10-08&apos;, &apos;2018-11-01&apos;, &apos;2018-12-03&apos;, &apos;2019-01-02&apos;, &apos;2019-02-01&apos;, &apos;2019-03-01&apos;, &apos;2019-04-01&apos;, &apos;2019-05-06&apos;, &apos;2019-06-03&apos;], dtype=&apos;datetime64[ns]&apos;, length=343, freq=None)12345678910111213141516171819# 按照模型进行定投month_df = index_df.copy()month_df['pct_change'] = month_df['close'].pct_change()month_df = month_df[['close', 'pct_change']] # 按月整合数据save_money = []hold_money = []save_base = 1000for i in range(len(month_df)): if i == 0: save_money.append(save_base) hold_money.append(save_base) else: save_money.append(save_money[-1] + save_base) hold_money.append(hold_money[-1] * (1 + month_df['pct_change'][i]) + save_base)month_df['save_money'] = save_moneymonth_df['hold_money'] = hold_moneymonth_df.head(10) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } close pct_change save_money hold_money 1990-12-19 99.98 NaN 1000 1000.000000 1991-01-02 128.84 0.288658 2000 2288.657732 1991-02-01 129.51 0.005200 3000 3300.559320 1991-03-01 132.53 0.023319 4000 4377.523950 1991-04-01 120.73 -0.089036 5000 4987.764781 1991-05-02 113.16 -0.062702 6000 5675.022468 1991-06-03 115.97 0.024832 7000 6815.945172 1991-07-01 136.85 0.180047 8000 9043.132679 1991-08-01 145.24 0.061308 9000 10597.549071 1991-09-02 180.22 0.240843 10000 14149.891858 12345678910# 计算定投、收益曲线month_df['return_money'] = month_df['hold_money'] - month_df['save_money']month_df[['save_money', 'hold_money', 'return_money']].plot(figsize=(14, 7))plt.legend(['累积投入', '累积本息', '累积收入'])plt.show()print('累计投入: &#123;&#125;元'.format(month_df['save_money'][-1]))print('累计收益: &#123;&#125;元'.format(month_df['return_money'][-1]))print('最终本息累积: &#123;&#125;元'.format(month_df['hold_money'][-1]))print('绝对收益率为: &#123;&#125;%'.format((month_df['return_money'][-1] / month_df['save_money'][-1]) * 100)) 累计投入: 343000元 累计收益: 583956.3789768222元 最终本息累积: 926956.3789768222元 绝对收益率为: 170.24967317108522%三、指数分析，知已知彼从上面的模型可以看出，如果尽早的定投，并且在低估的时候开始定投，随着国家的发展，指数的不断攀升，累积的总体收益也是一直在上升的。虽然总体收益率不是很高，但在2015的时候，总资金曾达到160万左右。 由于此模型没有卖出，因此在牛市疯狂的时候，没有到盈利落实到口袋中，而在市场最高的位置，也在不断的投入资金，这样便将定投的平均成本摊高了。 因此，接下来我们想解决的问题是，能否在指数位置偏低的时候持续定投，而在指数位置走到某种高度以上时持续卖出呢？那用什么指标来评判指数的高低位置呢？ 了解点价值投资者的朋友，都应该听说过 PE 和 PB，它们可以用来评估标的价格是处于低估还是高估位置。因此，下面我们将 PE 和 PB 运用到指数上来，看看能否带来效果。 下面使用简单的中位数方式，求取指数每天的PE与PB。 1234567891011121314151617181920212223242526272829303132333435363738# 从聚宽获取上证指数的信息index = '000001.XSHG' # 指数 codeindex_info = get_security_info(index) # 指数信息start_date = index_info.start_date # 指数开始时间end_date = datetime.datetime.now().date() # 以当天为最后一天index_name = index_info.display_name # 指数全称# 定义一个函数，计算每天的成份股的平均pe/pbdef get_pe_pb(index_code, start_date, end_date): def iter_pe_pb(): # 一个获取PE/PB的生成器 trade_date = get_trade_days(start_date=start_date, end_date=end_date) for date in trade_date: stocks = get_index_stocks(index_code, date) q = query(valuation.pe_ratio, valuation.pb_ratio ).filter(valuation.pe_ratio != None, valuation.pb_ratio != None, valuation.code.in_(stocks)) df = get_fundamentals(q, date) # 通过分位值进行过滤异常值 # 这里并没有采用三倍标准差来去除极值，差异不大 quantile = df.quantile([0.25, 0.75]) df_pe = df.pe_ratio[(df.pe_ratio &gt; quantile.pe_ratio.values[0]) &amp;\\ (df.pe_ratio &lt; quantile.pe_ratio.values[1])] df_pb = df.pb_ratio[(df.pb_ratio &gt; quantile.pb_ratio.values[0]) &amp;\\ (df.pb_ratio &lt; quantile.pb_ratio.values[1])] yield date, df_pe.median(), df_pb.median() dict_result = [&#123;'date': value[0], 'pe': value[1], 'pb':value[2]&#125; for value in iter_pe_pb()] df_result = pd.DataFrame(dict_result) df_result.set_index('date', inplace=True) return df_resultdf_pe_pb = get_pe_pb(index, start_date, end_date)df_pe_pb.head(10) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } pb pe date 2005-01-04 2.01585 26.53715 2005-01-05 2.04450 26.94350 2005-01-06 2.02165 26.61115 2005-01-07 2.02360 26.77050 2005-01-10 2.04630 26.94320 2005-01-11 2.05100 26.99430 2005-01-12 2.04245 26.78615 2005-01-13 2.06330 26.81250 2005-01-14 2.02760 26.63980 2005-01-17 1.96960 25.85190 123# 可视化PE/PB曲线图df_pe_pb.plot(figsize=(14, 7), subplots=True)plt.show() 12345678910# 将PE/PB趋势与指数趋势一起展示，以作观察_, axs = plt.subplots(ncols=2, figsize=(14, 5))close = get_price(index, start_date=start_date, end_date=end_date).close_df = pd.DataFrame()_df['close'] = close_df['pe'] = df_pe_pb.pe_df['pb'] = df_pe_pb.pb_df[['close', 'pe']].plot(secondary_y=['pe'], ax=axs[0], alpha=.8)_df[['close', 'pb']].plot(secondary_y=['pb'], ax=axs[1], alpha=.8)plt.show() 如上图所示，可以看出，PE 与 PB 的大小会随着市场的起伏而呈现正相关性的波动。PE 的波动区间大概在 10 到 70 倍之间，而 PB 的波动范围大概在 0 到 7 之间。 1234567# 分析PE/PB数据分布情况_, axs = plt.subplots(nrows=2, ncols=2, figsize=(14, 7))sns.distplot(df_pe_pb.pe, ax=axs[0][0])sns.boxplot(df_pe_pb.pe, ax=axs[0][1])sns.distplot(df_pe_pb.pb, ax=axs[1][0])sns.boxplot(df_pe_pb.pb, ax=axs[1][1])plt.show() 这里，通过上图的正态分布图与箱线图可以看出，PE 与 PB 有两个峰值，PE 的值主要集中在 2439 倍区间，PB 的值主要集中在 2.13.6 倍之间。 另外，牛市顶时对就的 PE 与 PB 值数量相当少，并且与中间区间的值的距离相对比较远，以至于在箱线图上成为了离群点。通过这一点可以说明牛市顶一闪而过，时间非常短，产生的数据量也非常少。 整体来说，上图反应了中国股市熊长牛短的特点。因此，想要抓住牛市的机会，是需要而心等待的。 123# 观察PE/PB之间的关系sns.jointplot(x='pb',y='pe', data=df_pe_pb, height=7)plt.show() PE 与 PB 都可以用来对指数进行估值，那到底用哪个比较好呢？ 但通过上图的散点图发现，本研究对应的 PE 与 PB 数据存在线性相关的数据，也就是说这两个指标大致上是同步涨同步跌的，因此，无论用 PE 还是 PB 来进行估值，效果都差不多，因此，接下将使用 PE 进行高位位置的判断。 123456789# 将PE分成十个分位，查看各分位PE数量pe_array = df_pe_pb.pe.valuesvalue_counts = pd.cut(pe_array, 10).value_counts()print(value_counts)plt.figure(figsize=(14, 4))sns.barplot(x=np.arange(0, len(value_counts)), y=value_counts.values)plt.show() (15.708, 21.447] 248 (21.447, 27.129] 1170 (27.129, 32.811] 523 (32.811, 38.492] 757 (38.492, 44.174] 490 (44.174, 49.856] 118 (49.856, 55.538] 100 (55.538, 61.219] 103 (61.219, 66.901] 25 (66.901, 72.583] 12 dtype: int64 上图是将 PE 的值分成了 10 个分位，对每个分位 PE 的数量进行统计，可是以发现： 第 2 个柱体是最高的，说明第 2 个 10 分位的 PE 数据量最多。 整体上来看，柱状图呈左偏形态，说明 PE 长时间处于 5 分位以下。 第 9 与第 10 个柱体代表的量少得可怜，说明高估值区的时间非常短。 123456789101112131415161718# 刻画PE整体趋势的中等分位区间（40%~60%）def show_quantile(): _df = pd.DataFrame() df = df_pe_pb.copy() df.index.name = None _df['pe'] = df.pe _df = _df p_high = [_df.pe.quantile(i / 10.0) for i in [4, 5, 6]] for p_h, i in zip(p_high, [4, 5, 6]): _df[str(i / 10 * 100)+'%'] = p_h low_p = _df[_df.pe &lt; _df.pe.iloc[-1]] quantile_now = low_p.shape[0] / _df.shape[0] # 当前百分位值 last_p = _df.pe[-1] _df.plot(figsize=(14, 7))show_quantile() 上图将当前 PE 按时间序列进行可视化，并用三条线标出了 40%、50%、60% 分位的位置。再结合上面的统计，可以得出： 低估区的数据数量为：2686 估值适中区的数据数量为：608 高估区的数据数量为：240 比值为 2684:608:240。低估区间的时间是高估区时间的11.19倍。 12345# 计算比值low = value_counts[0:4].sum()medin = value_counts[4:6].sum()high = value_counts[6:10].sum()print('比值(&#123;&#125;：&#123;&#125;：&#123;&#125;)'.format(low, medin, high)) 比值(2698：608：240)四、模型构思，循序渐进由于PE/PB数据是从聚宽数据而来，最早的时间是2005年的数据，因此，相较于1990年的数据来说，数据量减少了不止一点。但不影响接下来的研究。 通过上面的分析，接下来提出的设想是：设定一个可参考的估值区，当小于该估值时，进行定投，反之则持续卖出。 上面我们已经计算出，PE 40 到 60 的估值范围为 32.811 ~ 49.856 之间，这里我们设定此区间为适中估值区间。 模型的描述如下： 当 PE 处于适中估值区间时，不做任何操作；当月准备的定投金归入回收资金中。 当 PE 低于适中估值区间时，持续定投。 当 PE 高于适中估值区间时，持续卖出；卖出的金额与当月准备的定投金归入回收资金中。 本模型不考虑交易费用与滑点，默认每次的投入本金都可以全部买进！ 123456789101112131415161718# 获取每个月的第一个交易日first_day = []for i in range(len(df_pe_pb)): date = df_pe_pb.index[i] if i == 0: first_day.append(date) else: last_date = df_pe_pb.index[i - 1] if date.day &lt; last_date.day: first_day.append(date)# 按月计算价格与涨跌幅度close = get_price(index, start_date=df_pe_pb.index[0], end_date=df_pe_pb.index[-1])['close']df = df_pe_pb.copy()df['close'] = closedf = df.loc[first_day]df['pct_change'] = df.close.pct_change()df.head(10) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } pb pe close pct_change date 2005-01-04 2.01585 26.53715 1242.77 NaN 2005-02-01 1.86520 24.02880 1188.93 -0.043323 2005-03-01 2.09300 26.67730 1303.41 0.096288 2005-04-01 1.86500 25.19810 1223.57 -0.061255 2005-05-09 1.59800 22.17390 1130.84 -0.075786 2005-06-01 1.57390 20.97550 1039.19 -0.081046 2005-07-01 1.55790 21.28340 1055.59 0.015782 2005-08-01 1.49010 20.81670 1088.95 0.031603 2005-09-01 1.71190 22.38690 1184.93 0.088140 2005-10-10 1.69390 22.21185 1138.95 -0.038804 1234567891011121314151617181920212223242526272829303132333435363738394041miden_estimation = (38.492, 49.856) # 中等估值的pe区间save_money = [] # 每月定存back_money = [] # 回收资金hold_money = [] # 持仓资金base_money = 1000 # 定投基准def trade(): for i in range(len(df)): pe = df['pe'][i] # 估值位 if i == 0: # 初始买入 # 1.计算买入金额 save_money.append(base_money) # 2. 计算回收金额 back_money.append(0) # 3. 计算持仓变化 hold_money.append(base_money) continue if pe &lt;= miden_estimation[0]: # 执行买入计算 # 1.计算买入金额 save_money.append(base_money) # 2. 计算回收金额 back_money.append(0) # 3. 计算持仓变化 hold_money.append(hold_money[-1] * (1 + df['pct_change'][i]) + base_money) elif pe &gt;= miden_estimation[-1]: # 执行卖出计算 # 1. 计算买入金额 save_money.append(0) # 2. 计算回收金额 back_money.append(base_money) # 3. 计算持仓变化 hold_money.append(hold_money[-1] * (1 + df['pct_change'][i]) - base_money) else: # 1.计算买入金额 save_money.append(0) # 2. 计算回收金额 back_money.append(0) # 3. 计算持仓变化 hold_money.append(hold_money[-1] * (1 + df['pct_change'][i]))trade() 12345678910111213141516df['save_money'] = save_money # 定投金额df['save_money_cumsum'] = df['save_money'].cumsum() # 定投累计金额df['hold_money'] = hold_money # 持仓金额df['back_money'] = back_money # 回收金额df['back_money_cumsum'] = df['back_money'].cumsum() # 累计回收金额df['total_money'] = df['hold_money'] + df['back_money_cumsum'] # 总资金df['return_money'] = df['total_money'] - df['save_money_cumsum'] # 持续收益df['return_rate'] = (df['total_money'] / df['save_money_cumsum']) - 1 # 持续收益率df[['save_money_cumsum', 'total_money', 'back_money_cumsum', 'return_money']].plot(figsize=(14, 7))plt.legend(['累积定投', '累计本息', '回收资金', '收益曲线'])plt.show()print('累计投入: &#123;&#125;元'.format(df['save_money_cumsum'][-1]))print('累计收益: &#123;&#125;元'.format(df['return_money'][-1]))print('最终本息累积: &#123;&#125;元'.format(df['total_money'][-1]))print('绝对收益率为: &#123;&#125;%'.format((df['return_money'][-1] / df['save_money_cumsum'][-1]) * 100)) 累计投入: 133000元 累计收益: 49155.86259384008元 最终本息累积: 182155.86259384008元 绝对收益率为: 36.95929518333841%12345678910111213141516171819# 展示各年投入金额money_year = &#123;&#125;for date in df.index: year = date.year if year in money_year.keys(): money_year[year] = money_year[year] + df.loc[date, 'save_money'] else: money_year[year] = df.loc[date, 'save_money'] money_mean = mean(list(money_year.values()))years_count = len(money_year) - 1money_year = &#123;key: [value] for key, value in money_year.items()&#125;df_money_year = pd.DataFrame(money_year, index=[''])df_money_year = df_money_year.Tdf_money_year.plot(figsize=(14, 4), kind='bar')plt.hlines(money_mean, 0, years_count, color='orange')plt.legend(['年均投入', '定投年金'])plt.show() 123456789101112# 展示各年的收益return_year = &#123;&#125;for date in df.index: year = date.year return_year[year] = df.loc[date, 'return_rate']return_year = &#123;key: [value] for key, value in return_year.items()&#125;return_df = pd.DataFrame(return_year, index=['return']).Treturn_df['diff'] = return_df['return'].diff()return_df['diff'].fillna(return_df['return'], inplace=True)return_df[['diff']].plot(figsize=(14, 4), kind='bar')plt.legend(['各年收益率'])plt.show() 从上面的模型来看，整个投资区间，回收资金过少，即不能很好的在市场上涨的时候将钱落袋为安。 由于买入与卖出都是按一个基准来操作的，因此，这里设想，是否可以越跌则买的越多，而越涨越卖出得越多呢？ 模拟描述： 当 PE 处于适中估值区间时，不做任何操作；当月准备的定投金归入回收资金中。 当 PE 低于适中估值区间时，持续定投；每低一个10%分位，则增加一倍倍投入。 当 PE 高于适中估值区间时，每高一个10%分位，则增加一倍卖出。在上面分析过程中发现低估值区间是高估值区间的11倍左右，因此，这里还在卖出的原倍数上乘以11. 本模型不考虑交易费用与滑点，默认每次的投入本金都可以全部买进！ 123456789101112131415161718# 获取每个月的第一个交易日first_day = []for i in range(len(df_pe_pb)): date = df_pe_pb.index[i] if i == 0: first_day.append(date) else: last_date = df_pe_pb.index[i - 1] if date.day &lt; last_date.day: first_day.append(date)# 按月计算价格与涨跌幅度close = get_price(index, start_date=df_pe_pb.index[0], end_date=df_pe_pb.index[-1])['close']df = df_pe_pb.copy()df['close'] = closedf = df.loc[first_day]df['pct_change'] = df.close.pct_change()df.head(10) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } pb pe close pct_change date 2005-01-04 2.01585 26.53715 1242.77 NaN 2005-02-01 1.86520 24.02880 1188.93 -0.043323 2005-03-01 2.09300 26.67730 1303.41 0.096288 2005-04-01 1.86500 25.19810 1223.57 -0.061255 2005-05-09 1.59800 22.17390 1130.84 -0.075786 2005-06-01 1.57390 20.97550 1039.19 -0.081046 2005-07-01 1.55790 21.28340 1055.59 0.015782 2005-08-01 1.49010 20.81670 1088.95 0.031603 2005-09-01 1.71190 22.38690 1184.93 0.088140 2005-10-10 1.69390 22.21185 1138.95 -0.038804 123456789def get_how_value(pe): how_value = [15.708,21.447,27.129,32.811,38.492,44.174, 49.856,55.538,61.219,66.901,72.583] for i, value in zip(range(0, len(how_value)) , how_value): # zip 包装了整数倍的分位值与对应的pe值区间 if how_value[i] &lt;= pe &lt; how_value[i + 1]: location = i + 1 _how_value = 5 - location # 以5为中等值 return _how_value # 返回基于中位的买入或卖出倍数 1234567891011121314151617181920212223242526272829303132333435miden_estimation = (38.492, 49.856) # 中等估值的pe区间save_money = [] # 每月定存back_money = [] # 回收资金hold_money = [] # 持仓资金base_money = 1000 # 定投基准def trade(): for i in range(len(df)): pe = df['pe'][i] # 估值位 how_value = get_how_value(pe) if i == 0: # 初始买入 # 1.计算买入金额 save_money.append(base_money) # 2. 计算回收金额 back_money.append(0) # 3. 计算持仓变化 hold_money.append(base_money) continue if how_value &gt; 0: # 执行买入计算 # 1.计算买入金额 save_money.append(base_money * how_value) # 2. 计算回收金额 back_money.append(0) # 3. 计算持仓变化 hold_money.append(hold_money[-1] * (1 + df['pct_change'][i]) + base_money * how_value) else: # 执行卖出计算 # 1. 计算买入金额 save_money.append(0) # 2. 计算回收金额 back_money.append(base_money * -how_value * 11) # 3. 计算持仓变化 hold_money.append(hold_money[-1] * (1 + df['pct_change'][i]) - base_money * -how_value * 11)trade() 12345678910111213141516df['save_money'] = save_money # 定投金额df['save_money_cumsum'] = df['save_money'].cumsum() # 定投累计金额df['hold_money'] = hold_money # 持仓金额df['back_money'] = back_money # 回收金额df['back_money_cumsum'] = df['back_money'].cumsum() # 累计回收金额df['total_money'] = df['hold_money'] + df['back_money_cumsum'] # 总资金df['return_money'] = df['total_money'] - df['save_money_cumsum'] # 持续收益df['return_rate'] = (df['total_money'] / df['save_money_cumsum']) - 1 # 持续收益率df[['save_money_cumsum', 'total_money', 'back_money_cumsum', 'return_money']].plot(figsize=(14, 7))plt.legend(['累积定投', '累计本息', '回收资金', '收益曲线'])plt.show()print('累计投入: &#123;&#125;元'.format(df['save_money_cumsum'][-1]))print('累计收益: &#123;&#125;元'.format(df['return_money'][-1]))print('最终本息累积: &#123;&#125;元'.format(df['total_money'][-1]))print('绝对收益率为: &#123;&#125;%'.format((df['return_money'][-1] / df['save_money_cumsum'][-1]) * 100)) 累计投入: 319000元 累计收益: 288684.23619299044元 最终本息累积: 607684.2361929904元 绝对收益率为: 90.49662576582772%12345678910111213141516171819# 展示各年投入金额money_year = &#123;&#125;for date in df.index: year = date.year if year in money_year.keys(): money_year[year] = money_year[year] + df.loc[date, 'save_money'] else: money_year[year] = df.loc[date, 'save_money'] money_mean = mean(list(money_year.values()))years_count = len(money_year) - 1money_year = &#123;key: [value] for key, value in money_year.items()&#125;df_money_year = pd.DataFrame(money_year, index=[''])df_money_year = df_money_year.Tdf_money_year.plot(figsize=(14, 4), kind='bar')plt.hlines(money_mean, 0, years_count, color='orange')plt.legend(['年均投入', '定投年金'])plt.show() 123456789101112# 展示各年的收益return_year = &#123;&#125;for date in df.index: year = date.year return_year[year] = df.loc[date, 'return_rate']return_year = &#123;key: [value] for key, value in return_year.items()&#125;return_df = pd.DataFrame(return_year, index=['return']).Treturn_df['diff'] = return_df['return'].diff()return_df['diff'].fillna(return_df['return'], inplace=True)return_df[['diff']].plot(figsize=(14, 4), kind='bar')plt.legend(['各年收益率'])plt.show() 模型有了很大的进步，总体说来，资金的增长主要靠的是持续的定投与高位的加倍卖出举动。 但该模型在使用了从过支到当下计算的估值区间，我们期望可以使用一种动态追踪的估值数字，来指导我们做定投。 设想：将表态的pe按照近一段时间，来评估当下pe占过去历史百分位的高度，此区间随着时间的移动，一来可以发生动态变化，二来可以不受太旧历史数据的影响。 那这个历史区间设置多久呢？在上面的计算中，我们发现一个牛熊的运动大概在7.5年左右。因此，我们在这里设置这个时间区间为7.5年。 来看看依照此方式计算出的结果： 123456789101112131415161718192021222324252627# 查看动态pe形态的分位趋势图def get_quantile(index_code, p, n, data): \"\"\"指数百分位展示。 Args: index_code: 指数 code。 p: 可以是 pe，也可以是 pb。 n: 指用于计算指数估值百分位的区间，如果是5指近5年数据。 data: 包含有 pe/pb 的 DataFrame。 Returns: 计算后的DataFrame。 \"\"\" # 这里的计算按一年244个交易日计算 windows = int(n * 244) # 将时间取整数 _df = data.copy() _df.index.name = None price = get_price(index_code, start_date=_df.index[0], end_date=_df.index[-1]) _df['close'] = price.close _df['quantile'] = _df[p].rolling(windows).apply(lambda x: pd.Series(x).rank().iloc[-1] / pd.Series(x).shape[0], raw=True) _df.dropna(inplace=True) _df['quantile'].plot(figsize=(14, 7)) # 画出适中估值区间 plt.fill_between(_df.index, y1=0.4, y2=0.6, color='orange', alpha=0.7) plt.annotate('适中估值区', (_df.index[-1], 0.5)) return _df# 展示指数百分位趋势图df_quantile = get_quantile(index, 'pe', 7.45, df_pe_pb) 12345678910111213141516171819202122232425# pe动态分位图与指数高低位的比较def show_quantile(index_code, p, n, data): \"\"\"指数百分位展示。 Args: index_code: 指数 code。 p: 可以是 pe，也可以是 pb。 n: 指用于计算指数估值百分位的区间，如果是5指近5年数据。 data: 包含有 pe/pb 的 DataFrame。 Returns: None. \"\"\" # 这里的计算按一年244个交易日计算 windows = int(n * 244) # 将时间取整数 _df = data.copy() _df.index.name = None price = get_price(index_code, start_date=_df.index[0], end_date=_df.index[-1]) _df['close'] = price.close _df['quantile'] = _df[p].rolling(windows).apply(lambda x: pd.Series(x).rank().iloc[-1] / pd.Series(x).shape[0], raw=True) _df.dropna(inplace=True) _df[['quantile', 'close']].plot(figsize=(14, 10), subplots=True) # 画出适中估值区间 # 展示指数百分位趋势图show_quantile(index, 'pe', 7.5, df_pe_pb) 由上我们可以看出，pe近7.5年的动态分位图可以比较恰当的描述指数的高低起伏。 由此作出以下模型构思。 模型描述： 以近7.5年的pe分位来指导定投操作； 当分位值低于适中估值区间时，按倍增法买入； 当分位值处于适中估值区间时，不做任何操作； 当分位值高于适中估值区间时，按照立方指数数倍卖出。 本模型不考虑交易费用与滑点，默认每次的投入本金都可以全部买进！ 123456789101112131415161718# 获取每个月的第一个交易日first_day = []for i in range(len(df_quantile)): date = df_quantile.index[i] if i == 0: first_day.append(date) else: last_date = df_quantile.index[i - 1] if date.day &lt; last_date.day: first_day.append(date)# 按月计算价格与涨跌幅度close = get_price(index, start_date=df_quantile.index[0], end_date=df_quantile.index[-1])['close']df = df_quantile.copy()df['close'] = closedf = df.loc[first_day]df['pct_change'] = df.close.pct_change()df.head(10) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } pb pe close quantile pct_change 2012-06-28 2.34595 23.62375 2195.84 0.201431 NaN 2012-07-02 2.41665 24.12060 2226.11 0.215190 0.013785 2012-08-01 2.23125 22.63260 2123.36 0.165107 -0.046157 2012-09-03 2.17690 21.89940 2059.15 0.114474 -0.030240 2012-10-08 2.20460 21.38255 2074.42 0.088608 0.007416 2012-11-01 2.16470 21.78270 2104.43 0.116676 0.014467 2012-12-03 1.82780 18.31150 1959.77 0.010457 -0.068741 2013-01-04 2.17510 21.58100 2276.99 0.112273 0.161866 2013-02-01 2.34590 23.32070 2419.02 0.219042 0.062376 2013-03-01 2.40170 24.69880 2359.51 0.270226 -0.024601 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748save_money = [] # 每月定存back_money = [] # 回收资金hold_money = [] # 持仓资金base_money = 1000 # 定投基准def trade(): for i in range(len(df)): quantile = df['quantile'][i] # 估值位 multiple = int((0.5 - quantile) * 10) # 定投倍数计算 if i == 0: # 初始买入 # 1.计算买入金额 _save_money = base_money * multiple save_money.append(_save_money) # 2. 计算回收金额 _back_money = 0 back_money.append(_back_money) # 3. 计算持仓变化 _hold_money = _save_money hold_money.append(_hold_money) continue if multiple &gt;=0: # 执行买入计算 # 1.计算买入金额 _save_money = base_money * multiple save_money.append(_save_money) # 2. 计算回收金额 _back_money = 0 back_money.append(_back_money) # 3. 计算持仓变化 _hold_money = hold_money[-1] * (1 + df['pct_change'][i]) + _save_money hold_money.append(_hold_money) else: # 执行卖出计算 # 1. 计算买入金额 _save_money = 0 save_money.append(_save_money) # 2. 计算回收金额 _back_money = base_money * (2 ** -multiple) # 按2的指数倍卖出 _hold_money = hold_money[-1] * (1 + df['pct_change'][i]) if _back_money &gt; _hold_money: _back_money = _hold_money if quantile &gt;= 1.0: _back_money = _hold_money # 如果达到100%分位，清仓 back_money.append(_back_money) # 3. 计算持仓变化 _hold_money = _hold_money - _back_money hold_money.append(_hold_money)trade() 12345678910111213141516df['save_money'] = save_money # 定投金额df['save_money_cumsum'] = df['save_money'].cumsum() # 定投累计金额df['hold_money'] = hold_money # 持仓金额df['back_money'] = back_money # 回收金额df['back_money_cumsum'] = df['back_money'].cumsum() # 累计回收金额df['total_money'] = df['hold_money'] + df['back_money_cumsum'] # 总资金df['return_money'] = df['total_money'] - df['save_money_cumsum'] # 持续收益df['return_rate'] = (df['total_money'] / df['save_money_cumsum']) - 1 # 持续收益率df[['save_money_cumsum', 'total_money', 'back_money_cumsum', 'return_money']].plot(figsize=(14, 7))plt.legend(['累积定投', '累计本息', '回收资金', '收益曲线'])plt.show()print('累计投入: &#123;&#125;元'.format(df['save_money_cumsum'][-1]))print('累计收益: &#123;&#125;元'.format(df['return_money'][-1]))print('最终本息累积: &#123;&#125;元'.format(df['total_money'][-1]))print('绝对收益率为: &#123;&#125;%'.format((df['return_money'][-1] / df['save_money_cumsum'][-1]) * 100)) 累计投入: 99000元 累计收益: 77142.48573219407元 最终本息累积: 176142.48573219407元 绝对收益率为: 77.92170275979198%12345678910111213141516171819# 展示各年投入金额money_year = &#123;&#125;for date in df.index: year = date.year if year in money_year.keys(): money_year[year] = money_year[year] + df.loc[date, 'save_money'] else: money_year[year] = df.loc[date, 'save_money'] money_mean = mean(list(money_year.values()))years_count = len(money_year) - 1money_year = &#123;key: [value] for key, value in money_year.items()&#125;df_money_year = pd.DataFrame(money_year, index=[''])df_money_year = df_money_year.Tdf_money_year.plot(figsize=(14, 4), kind='bar')plt.hlines(money_mean, 0, years_count, color='orange')plt.legend(['年均投入', '定投年金'])plt.show() 123456789101112# 展示各年的收益return_year = &#123;&#125;for date in df.index: year = date.year return_year[year] = df.loc[date, 'return_rate']return_year = &#123;key: [value] for key, value in return_year.items()&#125;return_df = pd.DataFrame(return_year, index=['return']).Treturn_df['diff'] = return_df['return'].diff()return_df['diff'].fillna(return_df['return'], inplace=True)return_df[['diff']].plot(figsize=(14, 4), kind='bar')plt.legend(['各年收益率'])plt.show() 由于采用了动态计算pe百分位高度的方式，又牺牲掉了7.5年时间的数据，因此这个模型的数据更少。 但通过观察，发现整体的收益很可观，再结果文章开始对于下个牛市的展望，我们可以期望在2021年左右，获得一次资产翻倍的机会。 另外，在定投的过程中，可以将加收的资金买入国债，以增加收益，如果经过了多轮牛熊后，更可以将回收的资金再次投入的下一次的定投中去，以达成在低估值区间买入更多份额的目标。 由于篇幅有限，这两种情况就不作演算了。 最后说一点，由于该模型是在历史几个牛熊数据上推理优化而得，因此，这是一个过拟合模型。但为何还要去研究呢？是因为，这一切都建立在指数有效的假设上。即：我们相信，中国的运势会越来越好，指数有低谷，也终将有高潮！ 接下来，我们将上面的模型尝试运用到沪深300指数上，检验一下效果。 12345678index = '000300.XSHG' # 指数 codeindex_info = get_security_info(index) # 指数信息start_date = index_info.start_date # 指数开始时间end_date = datetime.datetime.now().date() # 以当天为最后一天index_name = index_info.display_name # 指数全称df_pe_pb = get_pe_pb(index, start_date, end_date)df_pe_pb.head(10) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } pb pe date 2005-04-08 1.95560 20.30690 2005-04-11 1.95630 20.27660 2005-04-12 1.89530 19.94685 2005-04-13 1.95555 20.39210 2005-04-14 1.93260 19.93285 2005-04-15 1.89060 19.65655 2005-04-18 1.88145 19.49545 2005-04-19 1.89960 19.96190 2005-04-20 1.83585 19.86055 2005-04-21 1.80415 19.57075 12# 展示指数百分位趋势图df_quantile = get_quantile(index, 'pe', 7.45, df_pe_pb) 12# 展示指数百分位趋势图show_quantile(index, 'pe', 7.45, df_pe_pb) 123456789101112131415161718# 获取每个月的第一个交易日first_day = []for i in range(len(df_quantile)): date = df_quantile.index[i] if i == 0: first_day.append(date) else: last_date = df_quantile.index[i - 1] if date.day &lt; last_date.day: first_day.append(date)# 按月计算价格与涨跌幅度close = get_price(index, start_date=df_quantile.index[0], end_date=df_quantile.index[-1])['close']df = df_quantile.copy()df['close'] = closedf = df.loc[first_day]df['pct_change'] = df.close.pct_change()df.head(10) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } pb pe close quantile pct_change 2012-09-21 1.93745 17.02400 2199.06 0.106769 NaN 2012-10-08 1.98520 17.63935 2270.05 0.135113 0.032282 2012-11-01 1.93975 18.08920 2297.88 0.177766 0.012260 2012-12-03 1.66340 15.75390 2108.85 0.040726 -0.082263 2013-01-04 2.10385 18.96275 2524.41 0.261970 0.197055 2013-02-01 2.22630 20.12825 2743.32 0.329114 0.086717 2013-03-01 2.20090 20.36475 2668.84 0.344524 -0.027150 2013-04-01 1.98140 18.83550 2493.19 0.238305 -0.065815 2013-05-02 1.87415 17.33815 2449.64 0.114474 -0.017468 2013-06-03 2.00610 18.97265 2602.62 0.238855 0.062450 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748save_money = [] # 每月定存back_money = [] # 回收资金hold_money = [] # 持仓资金base_money = 1000 # 定投基准def trade(): for i in range(len(df)): quantile = df['quantile'][i] # 估值位 multiple = int((0.5 - quantile) * 10) # 定投倍数计算 if i == 0: # 初始买入 # 1.计算买入金额 _save_money = base_money * multiple save_money.append(_save_money) # 2. 计算回收金额 _back_money = 0 back_money.append(_back_money) # 3. 计算持仓变化 _hold_money = _save_money hold_money.append(_hold_money) continue if multiple &gt;=0: # 执行买入计算 # 1.计算买入金额 _save_money = base_money * multiple save_money.append(_save_money) # 2. 计算回收金额 _back_money = 0 back_money.append(_back_money) # 3. 计算持仓变化 _hold_money = hold_money[-1] * (1 + df['pct_change'][i]) + _save_money hold_money.append(_hold_money) else: # 执行卖出计算 # 1. 计算买入金额 _save_money = 0 save_money.append(_save_money) # 2. 计算回收金额 _back_money = base_money * (2 ** -multiple) # 按2的指数倍卖出 _hold_money = hold_money[-1] * (1 + df['pct_change'][i]) if _back_money &gt; _hold_money: _back_money = _hold_money if quantile &gt;= 1.0: _back_money = _hold_money # 如果达到100%分位，清仓 back_money.append(_back_money) # 3. 计算持仓变化 _hold_money = _hold_money - _back_money hold_money.append(_hold_money)trade() 12345678910111213141516df['save_money'] = save_money # 定投金额df['save_money_cumsum'] = df['save_money'].cumsum() # 定投累计金额df['hold_money'] = hold_money # 持仓金额df['back_money'] = back_money # 回收金额df['back_money_cumsum'] = df['back_money'].cumsum() # 累计回收金额df['total_money'] = df['hold_money'] + df['back_money_cumsum'] # 总资金df['return_money'] = df['total_money'] - df['save_money_cumsum'] # 持续收益df['return_rate'] = (df['total_money'] / df['save_money_cumsum']) - 1 # 持续收益率df[['save_money_cumsum', 'total_money', 'back_money_cumsum', 'return_money']].plot(figsize=(14, 7))plt.legend(['累积定投', '累计本息', '回收资金', '收益曲线'])plt.show()print('累计投入: &#123;&#125;元'.format(df['save_money_cumsum'][-1]))print('累计收益: &#123;&#125;元'.format(df['return_money'][-1]))print('最终本息累积: &#123;&#125;元'.format(df['total_money'][-1]))print('绝对收益率为: &#123;&#125;%'.format((df['return_money'][-1] / df['save_money_cumsum'][-1]) * 100)) 累计投入: 89000元 累计收益: 49339.34427308533元 最终本息累积: 138339.34427308533元 绝对收益率为: 55.43746547537677%12345678910111213141516171819# 展示各年投入金额money_year = &#123;&#125;for date in df.index: year = date.year if year in money_year.keys(): money_year[year] = money_year[year] + df.loc[date, 'save_money'] else: money_year[year] = df.loc[date, 'save_money'] money_mean = mean(list(money_year.values()))years_count = len(money_year) - 1money_year = &#123;key: [value] for key, value in money_year.items()&#125;df_money_year = pd.DataFrame(money_year, index=[''])df_money_year = df_money_year.Tdf_money_year.plot(figsize=(14, 4), kind='bar')plt.hlines(money_mean, 0, years_count, color='orange')plt.legend(['年均投入', '定投年金'])plt.show() 123456789101112# 展示各年的收益return_year = &#123;&#125;for date in df.index: year = date.year return_year[year] = df.loc[date, 'return_rate']return_year = &#123;key: [value] for key, value in return_year.items()&#125;return_df = pd.DataFrame(return_year, index=['return']).Treturn_df['diff'] = return_df['return'].diff()return_df['diff'].fillna(return_df['return'], inplace=True)return_df[['diff']].plot(figsize=(14, 4), kind='bar')plt.legend(['各年收益率'])plt.show() 通过以上的模型，我们可以观察到，一个牛熊的时间，投入的资产可以约摸翻一倍。根据72法则（72 / 年化利率 = 资产翻倍时间），得出 72 / 7.5年 = 9.6%,即，我们可以期望通过定投实现年化9.6%的年化复利效果。 作为朝九晚五甚至是996的工薪族来说，这无疑是一个振奋人心的消息。由于没有足够的时间关心投资市场的情况，也没有足够的知识去创建高频的交易模型，通过量化定投，可以每月看一次市场估值，根据百分位而选择适当的金额投入，一来强制自己每月储蓄，二来在时间横向发展过程中，渐渐的壮大资金，7.5年对工薪族来说，是一个恰当而合适的机会！ 定投并不是没有风险的，在投资过程中，就像上图一样，有某些年份是要亏损的，但只要做到耐心等待，合理分投，不盲目跟风，一定会迎一份属于你的惊喜！ 致天下所有奋斗者！","categories":[{"name":"python","slug":"python","permalink":"www.hicoder.com.cn/categories/python/"},{"name":"量化","slug":"python/量化","permalink":"www.hicoder.com.cn/categories/python/%E9%87%8F%E5%8C%96/"}],"tags":[{"name":"量化","slug":"量化","permalink":"www.hicoder.com.cn/tags/%E9%87%8F%E5%8C%96/"},{"name":"python","slug":"python","permalink":"www.hicoder.com.cn/tags/python/"}]},{"title":"KDJ指标在指数上的择时效应","slug":"KDJ指标在指数上的择时效应","date":"2020-05-04T01:51:31.000Z","updated":"2020-05-04T04:46:46.590Z","comments":true,"path":"2020/05/04/KDJ指标在指数上的择时效应/","link":"","permalink":"www.hicoder.com.cn/2020/05/04/KDJ%E6%8C%87%E6%A0%87%E5%9C%A8%E6%8C%87%E6%95%B0%E4%B8%8A%E7%9A%84%E6%8B%A9%E6%97%B6%E6%95%88%E5%BA%94/","excerpt":"123456\"\"\"导入常用模块\"\"\"import numpy as npimport pandas as pdimport matplotlib.pyplot as pltimport datetimefrom environment import * # 导入回测模块 KDJ指标计算函数1234567891011121314151617181920212223242526272829303132333435import talib as tlfrom functools import reduce# SMA计算函数def SMA(close, timeperiod) : close = np.nan_to_num(close) return reduce(lambda x, y: ((timeperiod - 1) * x + y) / timeperiod, close) # KDJ计算函数def KDJ(high, low, close, fastk_period, slowk_period, fastd_period) : kValue, dValue = tl.STOCHF(high, low, close, fastk_period, fastd_period=1, fastd_matype=0) kValue = np.array(list(map(lambda x : SMA(kValue[:x], slowk_period), range(1, len(kValue) + 1)))) dValue = np.array(list(map(lambda x : SMA(kValue[:x], fastd_period), range(1, len(kValue) + 1)))) jValue = 3 * kValue - 2 * dValue func = lambda arr : np.array([0 if x &lt; 0 else (100 if x &gt; 100 else x) for x in arr]) kValue = func(kValue) dValue = func(dValue) jValue = func(jValue) return kValue, dValue, jValue# 获取某标的的KDJ信息def get_kdj(stock, count, end_date, unit): data = get_bars(security=stock, count=count, unit=unit, include_now=False, end_dt=end_date, fq_ref_date=None) close = data['close'] open = data['open'] high = data['high'] low = data['low'] return KDJ(high, low, close, 9, 3, 3)","text":"123456\"\"\"导入常用模块\"\"\"import numpy as npimport pandas as pdimport matplotlib.pyplot as pltimport datetimefrom environment import * # 导入回测模块 KDJ指标计算函数1234567891011121314151617181920212223242526272829303132333435import talib as tlfrom functools import reduce# SMA计算函数def SMA(close, timeperiod) : close = np.nan_to_num(close) return reduce(lambda x, y: ((timeperiod - 1) * x + y) / timeperiod, close) # KDJ计算函数def KDJ(high, low, close, fastk_period, slowk_period, fastd_period) : kValue, dValue = tl.STOCHF(high, low, close, fastk_period, fastd_period=1, fastd_matype=0) kValue = np.array(list(map(lambda x : SMA(kValue[:x], slowk_period), range(1, len(kValue) + 1)))) dValue = np.array(list(map(lambda x : SMA(kValue[:x], fastd_period), range(1, len(kValue) + 1)))) jValue = 3 * kValue - 2 * dValue func = lambda arr : np.array([0 if x &lt; 0 else (100 if x &gt; 100 else x) for x in arr]) kValue = func(kValue) dValue = func(dValue) jValue = func(jValue) return kValue, dValue, jValue# 获取某标的的KDJ信息def get_kdj(stock, count, end_date, unit): data = get_bars(security=stock, count=count, unit=unit, include_now=False, end_dt=end_date, fq_ref_date=None) close = data['close'] open = data['open'] high = data['high'] low = data['low'] return KDJ(high, low, close, 9, 3, 3) KDJ的使用方法可以参考：https://www.joinquant.com/view/community/detail/16464 KDJ指标使用方法 一KDJ是一种摆动指标，20与80的位置是我们对当前超买超卖状态的最基本判断。接下来的择时条件如下： 当D线处于20位置以下时，买进； 当D线处于80位置以上时，卖出； 另外，20与80的位置并不是硬性指标，我们可以为其指定一个浮动范围；我们将这个范围N值定在1%~9%之间，然后做回测，并查看其结果。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152trade_list = []N =[n/100 for n in range(1, 10)]for n in N: \"\"\"初始化以下内容\"\"\" context = Context() # 账户对象 order = Order(context) # 下单对象 trade = Trade(context, order) # 回测对旬 context.start_date = '2005-05-01' context.end_date = '2019-02-22' context.universe = ['000300.XSHG'] context.base = '000300.XSHG' \"\"\"策略主体\"\"\" def handle(context, order): stock = context.universe[0] current_date = trade.context.current_dt kdj_day = get_kdj(stock, 30, current_date, '1d') line_bottm = 20 * (1+n) line_top = 80 * (1-n) k1 = kdj_day[0][-1] d1 = kdj_day[1][-1] j1 = kdj_day[2][-1] k2 = kdj_day[0][-2] d2 = kdj_day[1][-2] j2 = kdj_day[2][-2] close = get_price(security=stock, end_date=context.current_dt, frequency='daily', fields=None, skip_paused=False, fq='pre', count=5)['close'] if d2 &gt; line_bottm and d1 &lt; line_bottm : if stock in context.position.keys(): return order.buy(stock, close[-1], context.cash // close[-1]) elif d2 &lt; line_top and d1 &gt; line_top: if stock not in context.position.keys(): return order.sell(stock, close[-1], context.position[stock]['count']) \"\"\"执行策略\"\"\" trade.trade(handle, show=False, log=True) trade_list.append(trade)# 展示Trade.show_ratio_compare('n', N, trade_list, 3, 3) End Time : 2019-03-10 16:01:27.192853, Elapsed Time: 0:00:18.351210 End Time : 2019-03-10 16:01:45.031913, Elapsed Time: 0:00:17.838861 End Time : 2019-03-10 16:02:02.843599, Elapsed Time: 0:00:17.811513 End Time : 2019-03-10 16:02:20.318987, Elapsed Time: 0:00:17.475214 End Time : 2019-03-10 16:02:38.392089, Elapsed Time: 0:00:18.072942 End Time : 2019-03-10 16:02:55.567773, Elapsed Time: 0:00:17.175470 End Time : 2019-03-10 16:03:13.802732, Elapsed Time: 0:00:18.234765 End Time : 2019-03-10 16:03:32.918843, Elapsed Time: 0:00:19.115479 End Time : 2019-03-10 16:03:51.401436, Elapsed Time: 0:00:18.482391 1Trade.show_result('n', N, trade_list) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } alpha beta 交易次数 回测时间 基准收益 夏普比率 年化收益 最大回撤 盈亏比 策略收益 胜率 n 0.01 -0.088320 0.3854 24 2005-05-01~2019-02-22 2.7662 -4.0289 -0.0237 0.5978 0.6680 -0.2740 0.5417 0.07 -0.092384 0.3463 27 2005-05-01~2019-02-22 2.7662 -4.1066 -0.0303 0.6063 0.5964 -0.3364 0.5185 0.08 -0.100810 0.3648 29 2005-05-01~2019-02-22 2.7662 -4.1761 -0.0375 0.6415 0.5394 -0.3995 0.5172 0.04 -0.100655 0.3468 24 2005-05-01~2019-02-22 2.7662 -4.4318 -0.0385 0.5986 0.4970 -0.4077 0.5417 0.05 -0.102086 0.3445 25 2005-05-01~2019-02-22 2.7662 -4.3913 -0.0401 0.5986 0.4827 -0.4205 0.5200 0.02 -0.106029 0.3877 24 2005-05-01~2019-02-22 2.7662 -4.7414 -0.0413 0.5925 0.4860 -0.4300 0.5000 0.06 -0.106598 0.3604 27 2005-05-01~2019-02-22 2.7662 -4.3707 -0.0436 0.6219 0.4449 -0.4480 0.4444 0.09 -0.108414 0.3642 29 2005-05-01~2019-02-22 2.7662 -4.3274 -0.0452 0.6370 0.4550 -0.4600 0.5172 0.03 -0.114031 0.3821 24 2005-05-01~2019-02-22 2.7662 -4.9898 -0.0497 0.6090 0.4252 -0.4928 0.5000 从上图来看，kdj在超买与超卖区的反应对于沪深300指数来说，反应并不好。 KDJ使用方法 二 当k线与d线形成金叉时买进； 当k线与d线形成死叉时卖出； 金叉与死叉形成时，最小的时间段是前天与当天的值的比较，这个时间段也可以被当作一种参数D，其取值范围是1~9天。查看回测结果： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849trade_list = []D = range(1, 10)for d in D: \"\"\"初始化以下内容\"\"\" context = Context() # 账户对象 order = Order(context) # 下单对象 trade = Trade(context, order) # 回测对旬 context.start_date = '2005-05-01' context.end_date = '2019-02-22' context.universe = ['000300.XSHG'] context.base = '000300.XSHG' \"\"\"策略主体\"\"\" def handle(context, order): stock = context.universe[0] current_date = trade.context.current_dt kdj_day = get_kdj(stock, 30, current_date, '1d') k1 = kdj_day[0][-1] d1 = kdj_day[1][-1] j1 = kdj_day[2][-1] k2 = kdj_day[0][-d-1] d2 = kdj_day[1][-d-1] j2 = kdj_day[2][-d-1] close = get_price(security=stock, end_date=context.current_dt, frequency='daily', fields=None, skip_paused=False, fq='pre', count=5)['close'] if k2 &lt; d2 and k1 &gt; d1: if stock in context.position.keys(): return order.buy(stock, close[-1], context.cash // close[-1]) elif k2 &gt; d2 and k1 &lt; d1: if stock not in context.position.keys(): return order.sell(stock, close[-1], context.position[stock]['count']) \"\"\"执行策略\"\"\" trade.trade(handle, show=False, log=True) trade_list.append(trade)# 展示Trade.show_ratio_compare('d', D, trade_list, 3, 3) End Time : 2019-03-10 16:04:13.577469, Elapsed Time: 0:00:20.034098 End Time : 2019-03-10 16:04:33.005696, Elapsed Time: 0:00:19.428044 End Time : 2019-03-10 16:04:52.154929, Elapsed Time: 0:00:19.149037 End Time : 2019-03-10 16:05:12.142793, Elapsed Time: 0:00:19.987659 End Time : 2019-03-10 16:05:31.073016, Elapsed Time: 0:00:18.930031 End Time : 2019-03-10 16:05:51.557113, Elapsed Time: 0:00:20.483901 End Time : 2019-03-10 16:06:10.902478, Elapsed Time: 0:00:19.345159 End Time : 2019-03-10 16:06:29.924519, Elapsed Time: 0:00:19.021839 End Time : 2019-03-10 16:06:48.871547, Elapsed Time: 0:00:18.946834 1Trade.show_result('d', D, trade_list) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } alpha beta 交易次数 回测时间 基准收益 夏普比率 年化收益 最大回撤 盈亏比 策略收益 胜率 d 2 0.009414 0.4432 290 2005-05-01~2019-02-22 2.7662 1.6912 0.0777 0.4224 1.1965 1.7096 0.4655 3 0.008740 0.4325 260 2005-05-01~2019-02-22 2.7662 1.6995 0.0763 0.4995 1.2031 1.6645 0.4846 1 -0.015884 0.4357 311 2005-05-01~2019-02-22 2.7662 1.4410 0.0519 0.4396 1.1350 0.9625 0.4759 8 -0.016955 0.4320 191 2005-05-01~2019-02-22 2.7662 1.7708 0.0506 0.6069 1.2340 0.9302 0.5340 4 -0.024804 0.4273 240 2005-05-01~2019-02-22 2.7662 0.9874 0.0424 0.4962 1.1123 0.7400 0.4708 5 -0.035541 0.4236 226 2005-05-01~2019-02-22 2.7662 0.6092 0.0315 0.5534 1.0970 0.5111 0.4779 6 -0.039586 0.4376 209 2005-05-01~2019-02-22 2.7662 0.5555 0.0283 0.5664 1.0921 0.4508 0.4976 7 -0.042921 0.4295 199 2005-05-01~2019-02-22 2.7662 0.3532 0.0245 0.5844 1.0933 0.3800 0.5075 9 -0.046487 0.4211 181 2005-05-01~2019-02-22 2.7662 0.0361 0.0204 0.5937 1.0899 0.3082 0.4972 从上面结果来看，当d=2时回测的效果比较好，但整体看来，仍旧没有跑赢大盘。因此，效果也并不理想。 KDJ使用方法 三 当j线与价格发生底背离时，买进； 当j线与价格发生顶背离时，卖出； 背离计算的是一段时间内，j线的趋势与价格的趋势在方向上不一致，把时间段设为D值，取值范围是1~9天。回测并查看结果： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849trade_list = []D = range(1, 10)for d in D: \"\"\"初始化以下内容\"\"\" context = Context() # 账户对象 order = Order(context) # 下单对象 trade = Trade(context, order) # 回测对旬 context.start_date = '2005-05-01' context.end_date = '2019-02-22' context.universe = ['000300.XSHG'] context.base = '000300.XSHG' \"\"\"策略主体\"\"\" def handle(context, order): stock = context.universe[0] current_date = trade.context.current_dt kdj_day = get_kdj(stock, 30, current_date, '1d') k1 = kdj_day[0][-1] d1 = kdj_day[1][-1] j1 = kdj_day[2][-1] k2 = kdj_day[0][-d-1] d2 = kdj_day[1][-d-1] j2 = kdj_day[2][-d-1] close = get_price(security=stock, end_date=context.current_dt, frequency='daily', fields=None, skip_paused=False, fq='pre', count=20)['close'] if j1 &gt; j2 and close[-1] &lt; close[-d-1]: if stock in context.position.keys(): return order.buy(stock, close[-1], context.cash // close[-1]) elif j1 &lt; j2 and close[-1] &gt; close[-d-1]: if stock not in context.position.keys(): return order.sell(stock, close[-1], context.position[stock]['count']) \"\"\"执行策略\"\"\" trade.trade(handle, show=False, log=True) trade_list.append(trade)# 展示Trade.show_ratio_compare('d', D, trade_list, 3, 3) End Time : 2019-03-10 16:07:10.097162, Elapsed Time: 0:00:19.401507 End Time : 2019-03-10 16:07:30.041172, Elapsed Time: 0:00:19.943802 End Time : 2019-03-10 16:07:51.642053, Elapsed Time: 0:00:21.600708 End Time : 2019-03-10 16:08:12.491229, Elapsed Time: 0:00:20.848990 End Time : 2019-03-10 16:08:32.879961, Elapsed Time: 0:00:20.388533 End Time : 2019-03-10 16:08:53.409177, Elapsed Time: 0:00:20.528626 End Time : 2019-03-10 16:09:12.488550, Elapsed Time: 0:00:19.079192 End Time : 2019-03-10 16:09:32.450308, Elapsed Time: 0:00:19.961573 End Time : 2019-03-10 16:09:52.517584, Elapsed Time: 0:00:20.067092 1Trade.show_result('d', D, trade_list) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } alpha beta 交易次数 回测时间 基准收益 夏普比率 年化收益 最大回撤 盈亏比 策略收益 胜率 d 1 -0.077736 0.4270 451 2005-05-01~2019-02-22 2.7662 -2.0861 -0.0105 0.6100 0.9727 -0.1313 0.6341 6 -0.110904 0.4822 109 2005-05-01~2019-02-22 2.7662 -4.2251 -0.0402 0.6891 0.7025 -0.4208 0.5688 3 -0.117829 0.5435 199 2005-05-01~2019-02-22 2.7662 -5.1090 -0.0432 0.6616 0.7790 -0.4446 0.6281 9 -0.113946 0.4604 81 2005-05-01~2019-02-22 2.7662 -4.6125 -0.0446 0.6432 0.6487 -0.4555 0.5802 7 -0.116218 0.4692 93 2005-05-01~2019-02-22 2.7662 -4.5738 -0.0463 0.7141 0.6920 -0.4683 0.6237 8 -0.126615 0.4572 79 2005-05-01~2019-02-22 2.7662 -5.4340 -0.0575 0.6776 0.5574 -0.5455 0.5696 2 -0.139678 0.4686 279 2005-05-01~2019-02-22 2.7662 -6.1486 -0.0698 0.7485 0.7312 -0.6187 0.5950 5 -0.157658 0.5356 121 2005-05-01~2019-02-22 2.7662 -6.7588 -0.0835 0.7425 0.5475 -0.6871 0.5785 4 -0.191193 0.4823 140 2005-05-01~2019-02-22 2.7662 -8.0771 -0.1204 0.8319 0.4296 -0.8192 0.5500 从上图来看，j线的背离效果也不好，k线与d线的背离效果这里就不做加测了。 下面展示本次研究效果最好的参数，即金叉与死叉条件下，d=2时的结果。123456789101112131415161718192021222324252627282930313233343536373839404142\"\"\"初始化以下内容\"\"\"context = Context() # 账户对象order = Order(context) # 下单对象trade = Trade(context, order) # 回测对旬context.start_date = '2005-05-01'context.end_date = '2019-02-22'context.universe = ['000300.XSHG']context.base = '000300.XSHG'\"\"\"策略主体\"\"\"def handle(context, order): stock = context.universe[0] current_date = trade.context.current_dt kdj_day = get_kdj(stock, 30, current_date, '1d') k1 = kdj_day[0][-1] d1 = kdj_day[1][-1] j1 = kdj_day[2][-1] k2 = kdj_day[0][-2-1] d2 = kdj_day[1][-2-1] j2 = kdj_day[2][-2-1] close = get_price(security=stock, end_date=context.current_dt, frequency='daily', fields=None, skip_paused=False, fq='pre', count=20)['close'] if k2 &lt; d2 and k1 &gt; d1: if stock in context.position.keys(): return order.buy(stock, close[-1], context.cash // close[-1]) elif k2 &gt; d2 and k1 &lt; d1: if stock not in context.position.keys(): return order.sell(stock, close[-1], context.position[stock]['count'])\"\"\"执行策略\"\"\"trade.trade(handle, show=True, log=True) End Time : 2019-03-10 16:11:04.901546, Elapsed Time: 0:00:20.362267","categories":[{"name":"python","slug":"python","permalink":"www.hicoder.com.cn/categories/python/"},{"name":"量化","slug":"python/量化","permalink":"www.hicoder.com.cn/categories/python/%E9%87%8F%E5%8C%96/"}],"tags":[{"name":"量化","slug":"量化","permalink":"www.hicoder.com.cn/tags/%E9%87%8F%E5%8C%96/"},{"name":"python","slug":"python","permalink":"www.hicoder.com.cn/tags/python/"}]},{"title":"聚宽回测分析模块","slug":"聚宽回测分析模块","date":"2020-05-04T01:33:36.000Z","updated":"2020-05-04T04:45:35.153Z","comments":true,"path":"2020/05/04/聚宽回测分析模块/","link":"","permalink":"www.hicoder.com.cn/2020/05/04/%E8%81%9A%E5%AE%BD%E5%9B%9E%E6%B5%8B%E5%88%86%E6%9E%90%E6%A8%A1%E5%9D%97/","excerpt":"下面的代码是一个简单的回测模块，数据需要引用聚宽的 jqdata。把下面的代码保存为一个.py 文件，然后上传到聚宽研究根目录下（或者你研究所在文件目录下），然后使用from 文件名 import *，即可导入该模块。 具体方法请参考：KDJ 指标在指数上的择时效应","text":"下面的代码是一个简单的回测模块，数据需要引用聚宽的 jqdata。把下面的代码保存为一个.py 文件，然后上传到聚宽研究根目录下（或者你研究所在文件目录下），然后使用from 文件名 import *，即可导入该模块。 具体方法请参考：KDJ 指标在指数上的择时效应 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390\"\"\"导入常用模块\"\"\"import numpy as npimport pandas as pdimport matplotlib.pyplot as pltimport datetimefrom jqdata import *from pylab import mplimport seaborn as snsmpl.rcParams['font.sans-serif'] = ['FangSong'] # 指定默认字体mpl.rcParams['axes.unicode_minus'] = False # 解决保存图像是负号'-'显示为方块的问题\"\"\"账户类\"\"\"class Context: def __init__(self): self.cash = self.Cash = 100000 # 默认初始资金 self.base = '000300.XSHG' # 默认参考基准 self.position = &#123;&#125; # 持仓 self.universe = [] # 标的池 self.current_dt = '2016-01-01' self.start_date = '2016-01-01' # 默认交易开始时间 self.end_date = '2016-12-31' # 默认交易结束时间 self.total_value = 0 # 总价值 self.trade_history = [] # 交易历史记录 self.day_value = [] # 日收益记录 self.trade_days = 0 # 记录每日收益 def write_ratio(self, security, date): the_value = self.cash for s in self.position.keys(): # 计算相对于上个交易日的涨跌幅度 price = get_price(s, end_date=date, frequency='daily', fields=['close'], skip_paused=False, fq='pre', count=10)['close'] value = self.position[s]['count']*price[-1] the_value += value self.day_value.append(&#123;'date':date, 'value':the_value&#125;) \"\"\"下单类\"\"\"class Order: context = Context() def __init__(self, context): self.context = context # 交易函数，买入与卖出 def buy(self, security, price, count): if price * count &gt; self.context.cash: print('资金不足，请调整数量！') return if security in self.context.position.keys(): print('暂不支持重复下单！') return _total_value = price * count self.context.cash -= _total_value _positon = &#123;'security': security, 'price': price, 'count': count, 'date': self.context.current_dt, 'type': 'buy', 'hold_value': price * count, 'available_cash': self.context.cash&#125; self.context.trade_history.append(_positon) self.context.total_value = self.context.cash + _total_value self.context.position[security] = _positon def sell(self, security, price, count): if security not in self.context.position.keys(): print('持仓中不包含标的&#123;&#125;，无法交易！'.format(security)) return if count != self.context.position[security]['count']: print('这支持分批卖出，请输入全部数量！') return _total_value = price * count self.context.cash += _total_value _positon = &#123;'security': security, 'price': price, 'count': count, 'date': self.context.current_dt, 'type': 'sell', 'hold_value': price * count, 'available_cash': self.context.cash&#125; self.context.trade_history.append(_positon) self.context.total_value = self.context.cash # ? del self.context.position[security]\"\"\"交易类\"\"\"class Trade: def __init__(self, context, order): self.context = context # 账户 self.order = order # 下单对象 self.result = &#123;&#125; # 回测后的评估指标 self.price = None # 价格缓存 self.maxdown_point = [] # 记录最大回撤点位 # 策略回测 def trade(self, func, show=True, log=False): time_start = datetime.datetime.now() self.price = get_price(security=self.context.base, start_date=self.context.start_date, end_date=self.context.end_date, frequency='daily', fields=None, skip_paused=False, fq='pre') close = self.price['close'] for i in range(0, len(close)): self.context.current_dt = close.index[i] self.context.trade_days = i+1 func(self.context, self.order) self.context.write_ratio(self.context.universe[0], self.context.current_dt) self.get_result() time_end = datetime.datetime.now() if log: print('End Time : &#123;0&#125;, Elapsed Time: &#123;1&#125;'.format(datetime.datetime.now(), time_end - time_start)) if show: self.show_ratio() # 查询交易记录详情 def get_trade_detail(self): _df = pd.DataFrame(self.context.trade_history, columns=['date', 'security', 'type', 'price', 'count', 'hold_value', 'available_cash']) _df.rename(columns=&#123;'date': '时间', 'security': '标的', 'type': '交易类型', 'price': '交易价格', 'count': '交易数量', 'hold_value': '持仓价值', 'available_cash': '可用资金'&#125;, inplace=True) return _df \"\"\"评估指标\"\"\" # 策略收益 def get_absolute_return(self): _cash = pd.DataFrame(self.context.day_value)['value'].iloc[-1] return (_cash - self.context.Cash) / self.context.Cash \"\"\" 年化收益率公式为： 年化收收益率 = （总收益 + 1）** (365.25/天数) -1 【计算自然日/年化收益率】 年化收收益率 = （总收益 + 1）** (250/天数) -1 【计算交易日/年化收益率】 \"\"\" # 策略年化收益率 def get_annualized_return(self): _cash = pd.DataFrame(self.context.day_value)['value'].iloc[-1] ratio = (_cash - self.context.Cash) / self.context.Cash return_value = (1 + ratio) ** (252 / len(self.context.day_value)) - 1 return return_value # 基准收益 def get_benchmark_return(self): ben_data = self.price benchmark_return = (ben_data['close'][-1] - ben_data['open'][0]) / ben_data['open'][0] return benchmark_return # 基准年化收益率 def get_anbenchmark_return(self): anbenchmark_return = (1 + self.get_benchmark_return()) ** (250 / len(self.context.day_value)) - 1 return anbenchmark_return # 计算盈亏比 def get_profit_loss_than(self): _df = pd.DataFrame(self.context.trade_history) if _df.shape[0] &lt;= 0: return 0 _df['total_value'] = _df['available_cash'] + _df['hold_value'] _sell = _df[_df['type'] == 'sell']['available_cash'] _trade_count = _df[_df['type'] == 'sell'].shape[0] _buy = _df[_df['type'] == 'buy']['total_value'][0:_trade_count] ratio = np.array(_sell) - np.array(_buy) return abs(ratio[ratio &gt; 0].sum()/ratio[ratio &lt; 0].sum()) # 计算交易次数 def get_trade_count(self): _df = pd.DataFrame(self.context.trade_history) if _df.shape[0] &lt;= 0: return 0 return len(_df[_df['type'] == 'sell'].index) # 计算胜率 def get_wine_rate(self): _df = pd.DataFrame(self.context.trade_history) if _df.shape[0] &lt;= 0: return 0 _df['total_value'] = _df['available_cash'] + _df['hold_value'] _sell = _df[_df['type'] == 'sell']['available_cash'] _trade_count = _df[_df['type'] == 'sell'].shape[0] _buy = _df[_df['type'] == 'buy']['total_value'][0:_trade_count] ratio = np.array(_sell) - np.array(_buy) return len(ratio[ratio &gt; 0])/len(ratio) # 夏普比率 def get_sharpe(self): _df = pd.DataFrame(self.context.day_value) if _df.shape[0] &lt;= 0: return 0 std = ((_df['value'] - self.context.Cash) / self.context.Cash).std() if std == 0: return 0 return (self.get_annualized_return() - 0.02) * np.sqrt(252) / std # beta def get_beta(self): ben_data = self.price ben_data['income'] = ben_data['close'].shift(1) ben_data['income1'] = ben_data['close'].astype(float) - ben_data['income'].astype(float) ben_data['income2'] = ben_data['income1'] / ben_data['income'] ben_data_income = np.array(list(ben_data['income2'].dropna())) # 策略每日收益 _df = pd.DataFrame(self.context.day_value) _df['income'] = _df['value'].shift(1) _df['income1'] = _df['value'].astype(float) - _df['income'].astype(float) _df['income2'] = _df['income1'] / _df['income'] _df_income = np.array(list(_df['income2'].dropna())) x = np.cov(ben_data_income, _df_income) y = np.var(ben_data_income) # 获取beta值 x_y_data = round(x[0][1]/y, 4) return x_y_data # alpha def get_alpha(self): alpha_data = self.get_annualized_return() - (0.04 + self.get_beta() * (self.get_anbenchmark_return() - 0.04)) return alpha_data \"\"\" 最大回撤计算方式： 在选定周期内任一历史点往后推，净值下降到最低点时的收益率回撤幅度的最大值。 计算方式有两种： 1. 往前计算，首先计算出每天和前面最高点比的最大回撤：1 - 当天值 / 前面的最大值，然后计算出这些数据里最大的值。 2. 往二计算，首先计算出每天和后面最低点比较的最大回撤：1 - 后面的最小值 / 当天值，然后计算出这些数据里最大值。 \"\"\" # 最大回撤 def get_maxdown(self): _df = pd.DataFrame(self.context.day_value) return_list = _df['value'] i = np.argmax((np.maximum.accumulate(return_list) - return_list) / np.maximum.accumulate(return_list)) # 结束位置 if i == 0: return 0 j = np.argmax(return_list[:i]) # 开始位置 # 记录最大回撤的点位 self.maxdown_point.append(_df.iloc[j]) self.maxdown_point.append(_df.iloc[i]) return (return_list[j] - return_list[i]) / (return_list[j]) # 总结回测信息 def get_result(self): _dic = &#123;'基准收益':round(self.get_benchmark_return(), 4), '策略收益':round(self.get_absolute_return(), 4), '年化收益':round(self.get_annualized_return(), 4), '最大回撤':round(self.get_maxdown(), 4), '夏普比率':round(self.get_sharpe(), 4), '盈亏比':round(self.get_profit_loss_than(), 4), '胜率':round(self.get_wine_rate(), 4), '交易次数':self.get_trade_count(), 'beta':self.get_beta(), 'alpha':self.get_alpha(), '回测时间':self.context.start_date+'~'+self.context.end_date&#125; self.result = _dic return _dic # 报表展示 @staticmethod def show_result(index_name, index_list, trade_list): _list = [] for i in range(0, len(trade_list)): _trade = trade_list[i] _dic = _trade.result _dic[index_name] = index_list[i] _list.append(_trade.result) _df = pd.DataFrame(_list) _df = _df.set_index(index_name) _df = _df.sort_values(by=['年化收益','最大回撤', 'alpha', '夏普比率', 'beta', '胜率'], ascending=(False, True, False, False, True, False)) return _df \"\"\"图例展示，所有的评估皆以收盘价为基准\"\"\" # 展示收益率曲线 def show_ratio(self, w=20, h=7): sns.set() _price = self.price # 大盘相对涨幅 start_price = _price['close'].iloc[0] _price['dapan_ratio'] = (_price['close'] - start_price) / start_price # 策略的相对涨幅 _day_price = pd.DataFrame(self.context.day_value) _day_price['trade_ratio'] = (_day_price['value'] - self.context.Cash) / self.context.Cash plt.figure(figsize=(w, h)) # 收益曲线 plt.plot(_price.index, _price['dapan_ratio'], linewidth = '2', color='#FF4500') plt.plot(_day_price['date'], _day_price['trade_ratio'], linewidth = '2', color='#1E90FF') # 回撤点位 x_list = [date['date'] for date in self.maxdown_point] y_list = [(date['value'] - self.context.Cash) / self.context.Cash for date in self.maxdown_point] plt.scatter(x_list, y_list, c='g',linewidths=7, marker='o') # 评估指标 plt.title('Benchmark Returns &#123;0&#125;|Total Returns &#123;1&#125;|Annualized Returns &#123;2&#125;|Max Drawdown &#123;3&#125;|RunTime &#123;4&#125;'.format( self.result['基准收益'], self.result['策略收益'], self.result['年化收益'], self.result['最大回撤'], self.result['回测时间']), fontsize=16) plt.grid(True) plt.legend(['Benchmark Returns', 'Total Returns'], loc=2, fontsize=14) plt.show() # 查看对比图 @staticmethod def show_ratio_compare(index_name, index_list, trade_list, r=2, c=2, w=16, h=9): \"\"\"指标名，指标列表，交易对象列表，绘图行数，绘图列数\"\"\" sns.set() # 计算一个子图的宽 width = w / c # 计算一个子图的高 high = width*0.56 figure,ax = plt.subplots(r, c, figsize=(w,(high+0.5)*r)) j = 0 for _ax in ax: for __ax in _ax: trade = trade_list[j] _price = trade.price # 大盘相对涨幅 start_price = _price['close'].iloc[0] _price['dapan_ratio'] = (_price['close'] - start_price) / start_price # 策略的相对涨幅 _day_price = pd.DataFrame(trade.context.day_value) _day_price['trade_ratio'] = (_day_price['value'] - trade.context.Cash) / trade.context.Cash __ax.plot(_price.index, _price['dapan_ratio'], color='#FF4500') __ax.plot(_day_price['date'], _day_price['trade_ratio'], color='#1E90FF') __ax.set_title('&#123;0&#125;=&#123;1&#125;'.format(index_name,index_list[j],), fontsize=14) j += 1 plt.show() @staticmethod def show_all_ratio(name , ma_list, trade_list, w=16, h=9): sns.set() _legend = [name+'='+str(_ma) for _ma in ma_list] plt.figure(figsize=(w, h)) for trade in trade_list: _day_price = pd.DataFrame(trade.context.day_value) _day_price['trade_ratio'] = (_day_price['value'] - trade.context.Cash) / trade.context.Cash plt.plot(_day_price['date'], _day_price['trade_ratio']) plt.legend(_legend) plt.show() class Picture: \"\"\"展示指标图\"\"\" passclass Model: \"\"\"交易模型，保存量化后的参数\"\"\" pass","categories":[{"name":"python","slug":"python","permalink":"www.hicoder.com.cn/categories/python/"},{"name":"量化","slug":"python/量化","permalink":"www.hicoder.com.cn/categories/python/%E9%87%8F%E5%8C%96/"}],"tags":[{"name":"量化","slug":"量化","permalink":"www.hicoder.com.cn/tags/%E9%87%8F%E5%8C%96/"},{"name":"python","slug":"python","permalink":"www.hicoder.com.cn/tags/python/"}]},{"title":"HiCoder上线啦","slug":"HiCoder上线啦","date":"2020-05-03T13:53:25.000Z","updated":"2020-05-04T04:44:16.547Z","comments":true,"path":"2020/05/03/HiCoder上线啦/","link":"","permalink":"www.hicoder.com.cn/2020/05/03/HiCoder%E4%B8%8A%E7%BA%BF%E5%95%A6/","excerpt":"","text":"HiCoder 终于和大家见面啦。 HiCoder 站点很早就搭建好了，但一直没想好要用它来做什么。也许这就是种缘份吧——你遇见一个人，起初不在意，可要分别了才发现难以割舍。我正是怀着这样一种心情，不断的往前摸索，忽然发现 HiCoder 可以为“程序猿”或“码家”们提供一个学习、吐槽和不断精进的基地。 时代在进步、科技在发展，趴在键盘上敲着代码的年轻人也越来越多，他们只身异地，披星\b戴月，陪着他们的可能仅有电脑和从来不打电话的手机。有多少人关心过程序员们的内心？有多少人曾关心过他们的身体？他们像也大多数人一样，渴望拥抱，渴望家的温暖，渴望被人倾听…… 也许我也不善言辞，但我想对那些努力的 Coder 们说一句：Hi!","categories":[{"name":"阅读","slug":"阅读","permalink":"www.hicoder.com.cn/categories/%E9%98%85%E8%AF%BB/"},{"name":"公告","slug":"阅读/公告","permalink":"www.hicoder.com.cn/categories/%E9%98%85%E8%AF%BB/%E5%85%AC%E5%91%8A/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"www.hicoder.com.cn/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"转-如何搭建基于Hexo的独立博客","slug":"https://xaoxuu.com","date":"2020-05-01T04:21:57.000Z","updated":"2020-05-04T04:46:53.278Z","comments":true,"path":"2020/05/01/https://xaoxuu.com/","link":"","permalink":"www.hicoder.com.cn/2020/05/01/https:/xaoxuu.com/","excerpt":"","text":"","categories":[{"name":"阅读","slug":"阅读","permalink":"www.hicoder.com.cn/categories/%E9%98%85%E8%AF%BB/"},{"name":"转载","slug":"阅读/转载","permalink":"www.hicoder.com.cn/categories/%E9%98%85%E8%AF%BB/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"www.hicoder.com.cn/tags/Hexo/"}],"author":{"name":"xaoxuu","avatar":"https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/avatar/avatar.png","url":"https://xaoxuu.com"}}],"categories":[{"name":"python","slug":"python","permalink":"www.hicoder.com.cn/categories/python/"},{"name":"量化","slug":"python/量化","permalink":"www.hicoder.com.cn/categories/python/%E9%87%8F%E5%8C%96/"},{"name":"阅读","slug":"阅读","permalink":"www.hicoder.com.cn/categories/%E9%98%85%E8%AF%BB/"},{"name":"公告","slug":"阅读/公告","permalink":"www.hicoder.com.cn/categories/%E9%98%85%E8%AF%BB/%E5%85%AC%E5%91%8A/"},{"name":"转载","slug":"阅读/转载","permalink":"www.hicoder.com.cn/categories/%E9%98%85%E8%AF%BB/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"量化","slug":"量化","permalink":"www.hicoder.com.cn/tags/%E9%87%8F%E5%8C%96/"},{"name":"python","slug":"python","permalink":"www.hicoder.com.cn/tags/python/"},{"name":"随笔","slug":"随笔","permalink":"www.hicoder.com.cn/tags/%E9%9A%8F%E7%AC%94/"},{"name":"Hexo","slug":"Hexo","permalink":"www.hicoder.com.cn/tags/Hexo/"}]}